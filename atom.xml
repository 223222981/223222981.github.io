<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BeGild Working</title>
  <icon>https://www.gravatar.com/avatar/60e2b17bf7b75b6259656295d5ba33ae</icon>
  <subtitle>BeGild&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://begild.top/"/>
  <updated>2018-03-10T13:06:52.365Z</updated>
  <id>http://begild.top/</id>
  
  <author>
    <name>BeGild</name>
    <email>yucangbao@126.com/1028366823@qq,com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>STM32 Flash的读写</title>
    <link href="http://begild.top/2018/03/07/STM32-Flash-Write-Read/"/>
    <id>http://begild.top/2018/03/07/STM32-Flash-Write-Read/</id>
    <published>2018-03-07T15:26:39.000Z</published>
    <updated>2018-03-10T13:06:52.365Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>这里记一下STM32F4板子FLASH的读写操作以及需要注意的地方。</p><h2 id="FLASH的写操作"><a href="#FLASH的写操作" class="headerlink" title="FLASH的写操作"></a>FLASH的写操作</h2><ol><li>FLASH由 ‘1’ 变为 ‘0’ 不能由 ‘0’ 变为 ‘1’ ，所以在写入之间需要检测是否为 ‘1’  ,并且擦除flash只能按照一个扇区来删除，由上可知，我们写入之前必须确保我们需要写入的地址读回来的值是0XFF，如果不是0XFF就需要将整个扇区擦除(扇区变为全 ‘1’ )。</li><li>写入操作(包括擦除)之前需要将FLASH解锁 <code>FLASH_Unlock()</code>，操作完成之后需要将FLASH上锁 <code>FLASH_Lock()</code> 。<a id="more"></a></li></ol><h2 id="正点原子的例子"><a href="#正点原子的例子" class="headerlink" title=" 正点原子的例子"></a><a href="http://www.alientek.com/" target="_blank" rel="noopener"> 正点原子</a>的例子</h2><ul><li>写入流程:<ul><li>解锁FLASH <code>FLASH_Unlock()</code>；</li><li>禁止数据缓存<code>FLASH_DataCacheCmd(DISABLE)</code>,根据你传入的起始地址 <code>WriteAddr</code> 和写入的字节数 <code>NumToWrite</code> 计算出结束地址 <code>endaddr</code>；</li><li>遍历整个写入范围，一旦发现非 ’1‘ 数据的出现就擦除整个扇区，他这里是字(Word)来检测的，所以地址 <code>addrx</code> 每次加4；</li><li>检测完毕并且擦除之后，进入写操作，每次写入一个字(4byte)的数据。所以 <code>WriteAddr</code> 每次加4, <code>u32 *pBuffer</code> 每次加1 ；</li><li>使能数据缓存<code>FLASH_DataCacheCmd(ENABLE)</code>，上锁FLASH <code>FLASH_Lock()</code>。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从指定地址开始写入指定长度的数据</span></span><br><span class="line"><span class="comment">//特别注意:因为STM32F4的扇区实在太大,没办法本地保存扇区数据,所以本函数</span></span><br><span class="line"><span class="comment">//     写地址如果非0XFF,那么会先擦除整个扇区且不保存扇区数据.所以</span></span><br><span class="line"><span class="comment">//     写非0XFF的地址,将导致整个扇区数据丢失.建议写之前确保扇区里</span></span><br><span class="line"><span class="comment">//     没有重要数据,最好是整个扇区先擦除了,然后慢慢往后写.</span></span><br><span class="line"><span class="comment">//该函数对OTP区域也有效!可以用来写OTP区!</span></span><br><span class="line"><span class="comment">//OTP区域地址范围:0X1FFF7800~0X1FFF7A0F</span></span><br><span class="line"><span class="comment">//WriteAddr:起始地址(此地址必须为4的倍数!!)</span></span><br><span class="line"><span class="comment">//pBuffer:数据指针</span></span><br><span class="line"><span class="comment">//NumToWrite:字(32位)数(就是要写入的32位数据的个数.)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">STMFLASH_Write</span><span class="params">(u32 WriteAddr, u32 *pBuffer, u32 NumToWrite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FLASH_Status status = FLASH_COMPLETE;</span><br><span class="line">    u32 addrx = <span class="number">0</span>;</span><br><span class="line">    u32 endaddr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(WriteAddr &lt; STM32_FLASH_BASE || WriteAddr % <span class="number">4</span>)<span class="keyword">return</span>;<span class="comment">//非法地址</span></span><br><span class="line">    FLASH_Unlock();<span class="comment">//解锁</span></span><br><span class="line">    FLASH_DataCacheCmd(DISABLE);<span class="comment">//FLASH擦除期间,必须禁止数据缓存</span></span><br><span class="line"></span><br><span class="line">    addrx = WriteAddr;<span class="comment">//写入的起始地址</span></span><br><span class="line">    endaddr = WriteAddr + NumToWrite * <span class="number">4</span>;<span class="comment">//写入的结束地址</span></span><br><span class="line">    <span class="keyword">if</span>(addrx &lt; <span class="number">0X1FFF0000</span>)<span class="comment">//只有主存储区,才需要执行擦除操作!!</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">while</span>(addrx &lt; endaddr)<span class="comment">//扫清一切障碍.(对非FFFFFFFF的地方,先擦除)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(STMFLASH_ReadWord(addrx) != <span class="number">0XFFFFFFFF</span>) <span class="comment">//有非0XFFFFFFFF的地方,要擦除这个扇区</span></span><br><span class="line">        &#123;</span><br><span class="line">        status = FLASH_EraseSector(STMFLASH_GetFlashSector(addrx), VoltageRange_3); <span class="comment">//VCC=2.7~3.6V之间!!</span></span><br><span class="line">        <span class="keyword">if</span>(status != FLASH_COMPLETE)<span class="keyword">break</span>;<span class="comment">//发生错误了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> addrx += <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(status == FLASH_COMPLETE)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">while</span>(WriteAddr &lt; endaddr) <span class="comment">//写数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(FLASH_ProgramWord(WriteAddr, *pBuffer) != FLASH_COMPLETE) <span class="comment">//写入数据</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//写入异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        WriteAddr += <span class="number">4</span>;</span><br><span class="line">        pBuffer++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FLASH_DataCacheCmd(ENABLE);<span class="comment">//FLASH擦除结束,开启数据缓存</span></span><br><span class="line">    FLASH_Lock();<span class="comment">//上锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试和分析<br>经过实验，擦除扇区的时间是很久的，擦除128KByte的扇区大概需要1s多。并且，不解锁虽然可以通过擦除函数并且返回 <code>FLASH_COMPLETE</code> 但是实际并没有擦除成功。我开始以为他这个耗时主要体现在读和判断，擦除操作比较快，😒但其实读120KByte的数据只需要3.9ms加上判断的时间也没多少主要的时间耗费在擦除操作上。😆另一个体现就是如果在 Keil 的工程选项里把擦除全部flash勾选，下载前的擦除的时间是很长的。下面是测试代码和解释结果。测试结果可以看出，擦除的时间并没有很大变化，因为都是需要一次性操作一个扇区，只要不超过一个扇区的长度都不会变化很大。写入和读出的时间保持线性变化。所有的测试都是用原子官方例程按照WORD(32bit)来写入的。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...上续代码</span><br><span class="line">  STMFLASH_Write(FLASH_SAVE_ADDR, (u32 *)&amp;txbuf, SIZE);<span class="comment">//写入一些数据保证flash不全为'1'</span></span><br><span class="line">  uprintf(USART1, <span class="string">"扇区预先不为全 '1'时写入:\r\n"</span>);</span><br><span class="line">  uprintf(USART1, <span class="string">"写入长度:%d\r\n"</span>, TEXT_LENTH);</span><br><span class="line">  <span class="comment">//原子的例子擦除flash再写入数据</span></span><br><span class="line">  STMFLASH_Write(FLASH_SAVE_ADDR, (u32 *)&amp;txbuf, SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(readbuf,<span class="number">0</span>,TEXT_LENTH);<span class="comment">//清空数据读取</span></span><br><span class="line">  StartTiming();</span><br><span class="line">  STMFLASH_Read(FLASH_SAVE_ADDR, (u32 *)&amp;readbuf, SIZE);</span><br><span class="line">  timems = GetTimeMs();</span><br><span class="line">  uprintf(USART1, <span class="string">"读出耗时:%.3fms\r\n"</span>, timems);</span><br><span class="line">  uprintf(USART1, <span class="string">"读出长度:%d\r\n----\r\n"</span>, TEXT_LENTH, <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)readbuf));</span><br><span class="line">...下续代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">STMFLASH_Write</span><span class="params">(u32 WriteAddr, u32 *pBuffer, u32 NumToWrite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...上续代码</span><br><span class="line">  FLASH_DataCacheCmd(DISABLE);<span class="comment">//FLASH擦除期间,必须禁止数据缓存</span></span><br><span class="line">  StartTiming();<span class="comment">//开始计时擦除扇区耗时</span></span><br><span class="line">.....上续代码</span><br><span class="line">timems = GetTimeMs(); </span><br><span class="line">uprintf(USART1,<span class="string">"擦除扇区耗时 :%.3fms\r\n"</span>,timems);</span><br><span class="line">StartTiming();<span class="comment">//开始写入计时</span></span><br><span class="line">    <span class="keyword">if</span>(status == FLASH_COMPLETE)</span><br><span class="line">    &#123;</span><br><span class="line">...上续代码</span><br><span class="line"> FLASH_Lock();<span class="comment">//上锁</span></span><br><span class="line"> timems = GetTimeMs();<span class="comment">//获取写入耗时</span></span><br><span class="line"> uprintf(USART1, <span class="string">"写入耗时:%.3fms\r\n"</span>, timems);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*测试结果 测试120、12K、120K(Byte)的数据*/</span></span><br><span class="line">扇区预先不为全 <span class="string">'1'</span>时写入:</span><br><span class="line">写入长度:<span class="number">120</span></span><br><span class="line">擦除扇区耗时 :<span class="number">1046.720</span>ms</span><br><span class="line">写入耗时:<span class="number">0.440</span>ms</span><br><span class="line">读出耗时:<span class="number">0.020</span>ms</span><br><span class="line">读出长度:<span class="number">120</span> </span><br><span class="line">----</span><br><span class="line">扇区预先不为全 <span class="string">'1'</span>时写入:</span><br><span class="line">写入长度:<span class="number">12288</span></span><br><span class="line">擦除扇区耗时 :<span class="number">1050.220</span>ms</span><br><span class="line">写入耗时:<span class="number">45.700</span>ms</span><br><span class="line">读出耗时:<span class="number">0.380</span>ms</span><br><span class="line">读出长度:<span class="number">12288</span> </span><br><span class="line">----</span><br><span class="line">扇区预先不为全 <span class="string">'1'</span>时写入:</span><br><span class="line">写入长度:<span class="number">122880</span></span><br><span class="line">擦除扇区耗时 :<span class="number">1051.860</span>ms</span><br><span class="line">写入耗时:<span class="number">458.700</span>ms</span><br><span class="line">读出耗时:<span class="number">3.880</span>ms</span><br><span class="line">读出长度:<span class="number">122880</span> </span><br><span class="line">----</span><br></pre></td></tr></table></figure><h2 id="改进擦除方式"><a href="#改进擦除方式" class="headerlink" title="改进擦除方式"></a>改进擦除方式</h2><ul><li>改进的一点想法<br>根据正点原子的测试结果来看，擦除扇区的时间是不可避免的，无非就是暴力一点不检测直接擦除(因为通常来说，如果你存储在固定的flash地址除了第一次之后都会有数据)。这样搞了之后从测试的结果来看提升并不明显。写120KByte的数据下擦除时间少了4ms左右😔(少了读取和判断的时间)。所以擦除的方式并没有很好的改进方法(标题党😈)。</li></ul><h2 id="通用性考虑"><a href="#通用性考虑" class="headerlink" title="通用性考虑"></a>通用性考虑</h2><ul><li>通过正点原子的例子熟悉了Flash的读写，但是只支持4字节对齐(WORD)的操作,我看了一下库的函数是可以支持 BYTE，HALFWORD,WORD, 和 DOUBLEWORD 的，不过 DOUBLEWORD 需要外部Vpp。所以想改进一些支持库函数里的各种byte(1-4) 的操作。</li><li>修改好之后测试一下测试代码和上面原版的差不多。只是写入函数换成了修改之后的<code>STMFLASH_WriteWithErase</code>，测试结果如下,测试的时候用的是WORD方式写入。和原子基本没有差别。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">扇区预先不为全 <span class="string">'1'</span>时写入:</span><br><span class="line">写入长度:<span class="number">120</span></span><br><span class="line">擦除扇区耗时 :<span class="number">1043.500</span>ms</span><br><span class="line">写入耗时:<span class="number">0.460</span>ms</span><br><span class="line">读出耗时:<span class="number">0.000</span>ms</span><br><span class="line">读出长度:<span class="number">120</span> </span><br><span class="line">----</span><br><span class="line">扇区预先不为全 <span class="string">'1'</span>时写入:</span><br><span class="line">写入长度:<span class="number">12288</span></span><br><span class="line">擦除扇区耗时 :<span class="number">1046.580</span>ms</span><br><span class="line">写入耗时:<span class="number">45.700</span>ms</span><br><span class="line">读出耗时:<span class="number">0.400</span>ms</span><br><span class="line">读出长度:<span class="number">12288</span> </span><br><span class="line">----</span><br><span class="line">扇区预先不为全 <span class="string">'1'</span>时写入:</span><br><span class="line">写入长度:<span class="number">122880</span></span><br><span class="line">擦除扇区耗时 :<span class="number">1050.860</span>ms</span><br><span class="line">写入耗时:<span class="number">459.140</span>ms</span><br><span class="line">读出耗时:<span class="number">3.900</span>ms</span><br><span class="line">读出长度:<span class="number">122880</span> </span><br><span class="line">----</span><br></pre></td></tr></table></figure></li></ul><h2 id="其他ByteSize方式写入"><a href="#其他ByteSize方式写入" class="headerlink" title="其他ByteSize方式写入"></a>其他ByteSize方式写入</h2><p>相对于用WORD来说用其他方式写入flash是要慢一些的。采用 BYTE 方式需要 大概<code>1832ms</code>,采用HALFWORD方式需要<code>920ms</code>左右。因为擦除都是采用的<code>VoltageRange_3</code>也就是WORD方式所以擦除时间差不多。</p><h2 id="分离操作的方式"><a href="#分离操作的方式" class="headerlink" title="分离操作的方式"></a>分离操作的方式</h2><ul><li>分离操作的意义<br>把擦除和写入分开。考虑到一个扇区是非常大的，一个扇区可能会存储多种数据。如果写入之前有数据就会导致整个扇区被擦除，数据就会丢失。所以采用分离的办法，把数据的写入和擦除分隔开，根据需要选择是否擦除扇区内的数据，保证在擦除的操作之前有相应的备份操作就OK了。这样即使忘记擦除那么也只是新的数据没法正确写到flash里面，其他部分的数据就不会被擦除，这样有利于更好的数据完整性。</li><li>测试结果和测试代码,经过测试分离之后的操作和没分离的时间上基本没什么差别，<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">分离操作方式写入flash:</span><br><span class="line">擦除扇区耗时:<span class="number">1023.320</span>ms</span><br><span class="line">写入长度:<span class="number">120</span> byte</span><br><span class="line">写入耗时:<span class="number">0.440</span>ms</span><br><span class="line">读出耗时:<span class="number">0.000</span>ms</span><br><span class="line">读出长度:<span class="number">120</span> byte</span><br><span class="line">****</span><br><span class="line">分离操作方式写入flash:</span><br><span class="line">擦除扇区耗时:<span class="number">1015.140</span>ms</span><br><span class="line">写入长度:<span class="number">12288</span> byte</span><br><span class="line">写入耗时:<span class="number">45.940</span>ms</span><br><span class="line">读出耗时:<span class="number">0.400</span>ms</span><br><span class="line">读出长度:<span class="number">12288</span> byte</span><br><span class="line">****</span><br><span class="line">合并操作方式写入flash:</span><br><span class="line">写入长度:<span class="number">122880</span></span><br><span class="line">擦除扇区耗时 :<span class="number">1010.480</span>ms</span><br><span class="line">写入耗时:<span class="number">461.420</span>ms</span><br><span class="line">读出耗时:<span class="number">3.900</span>ms</span><br><span class="line">读出长度:<span class="number">122880</span> </span><br><span class="line">****</span><br><span class="line"><span class="keyword">int</span> main（<span class="keyword">void</span>）</span><br><span class="line">&#123;</span><br><span class="line">...上续代码</span><br><span class="line">    uprintf(USART1, <span class="string">"分离操作方式写入flash:\r\n"</span>);</span><br><span class="line">    StartTiming();</span><br><span class="line">    status = StmEraseFlashSector(FLASH_SAVE_ADDR, TEXT_LENTH);</span><br><span class="line">    <span class="comment">//FLASH_DataCacheCmd(DISABLE);//FLASH擦除期间,必须禁止数据缓存</span></span><br><span class="line">    <span class="comment">//status = FLASH_EraseSector(STMFLASH_GetFlashSector(FLASH_SAVE_ADDR), VoltageRange_3); //VCC=2.7~3.6V之间!!</span></span><br><span class="line">    <span class="keyword">if</span>(status != FLASH_COMPLETE)</span><br><span class="line">    &#123;</span><br><span class="line">        uprintf(USART1, <span class="string">"擦除扇区失败:%d\r\n"</span>,status);    <span class="comment">//发生错误了</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    timems = GetTimeMs();</span><br><span class="line">    uprintf(USART1, <span class="string">"擦除扇区耗时:%.3fms\r\n"</span>, timems);</span><br><span class="line">uprintf(USART1, <span class="string">"写入长度:%d byte\r\n"</span>, TEXT_LENTH);</span><br><span class="line">    StartTiming();</span><br><span class="line">    <span class="comment">//不需要擦除falsh直接写数据</span></span><br><span class="line">    STMFLASH_WriteNoErase(FLASH_SAVE_ADDR, txbuf,TEXT_LENTH,ByteSize);</span><br><span class="line">    timems = GetTimeMs();</span><br><span class="line">    uprintf(USART1, <span class="string">"写入耗时:%.3fms\r\n"</span>, timems);</span><br><span class="line"><span class="built_in">memset</span>(readbuf,<span class="number">0</span>,TEXT_LENTH);<span class="comment">//清空数据读取</span></span><br><span class="line">    StartTiming();</span><br><span class="line">    STMFLASH_Read(FLASH_SAVE_ADDR,readbuf, TEXT_LENTH,ByteSize);</span><br><span class="line">    timems = GetTimeMs();</span><br><span class="line">    uprintf(USART1, <span class="string">"读出耗时:%.3fms\r\n"</span>, timems);</span><br><span class="line">    uprintf(USART1, <span class="string">"读出长度:%d byte\r\n****\r\n"</span>, TEXT_LENTH, <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)readbuf)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>搞了几天才把这个写完整。中途也进了好多的坑，浪费了好长时间。不过还是写完了。说一点注意的地方</p><ul><li>flash的写入地址不是偶数就可以，得是4的倍数。</li><li>无论是擦除还是写入都需要先解锁flash。读取则不需要。</li><li>对于同一个扇区的建议用分离的操作，并且在操作前根据需要把其他的数据读出来备份一下在写进去。</li></ul><p>关于本文的代码详见于<a href="https://coding.net/u/BycCoding/p/stm32f4_flash/git" target="_blank" rel="noopener">Coding项目</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里记一下STM32F4板子FLASH的读写操作以及需要注意的地方。&lt;/p&gt;
&lt;h2 id=&quot;FLASH的写操作&quot;&gt;&lt;a href=&quot;#FLASH的写操作&quot; class=&quot;headerlink&quot; title=&quot;FLASH的写操作&quot;&gt;&lt;/a&gt;FLASH的写操作&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;FLASH由 ‘1’ 变为 ‘0’ 不能由 ‘0’ 变为 ‘1’ ，所以在写入之间需要检测是否为 ‘1’  ,并且擦除flash只能按照一个扇区来删除，由上可知，我们写入之前必须确保我们需要写入的地址读回来的值是0XFF，如果不是0XFF就需要将整个扇区擦除(扇区变为全 ‘1’ )。&lt;/li&gt;
&lt;li&gt;写入操作(包括擦除)之前需要将FLASH解锁 &lt;code&gt;FLASH_Unlock()&lt;/code&gt;，操作完成之后需要将FLASH上锁 &lt;code&gt;FLASH_Lock()&lt;/code&gt; 。
    
    </summary>
    
      <category term="STM32" scheme="http://begild.top/categories/STM32/"/>
    
    
      <category term="Flash读写" scheme="http://begild.top/tags/Flash%E8%AF%BB%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>STM32自定义串口printf</title>
    <link href="http://begild.top/2018/03/01/STM32-UART-CustomPrintf/"/>
    <id>http://begild.top/2018/03/01/STM32-UART-CustomPrintf/</id>
    <published>2018-03-01T12:29:34.000Z</published>
    <updated>2018-03-02T03:31:07.877Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>硬件的调试通常可分为两大类，一种是用调试器将芯片和电脑连接通过单步等方式逐步运行进行调试，另一种就是printf大法在程序运行过程中输出调试信息。第一种比较深入，可以了解每一个变量，栈堆，函数等等的变化是比较系统化的调试。但我通常都是用printf来调试的，因为快速简单属于非介入的方式，调试完毕直接注释掉相关部分就行了。</p><h2 id="重定向-printf-函数"><a href="#重定向-printf-函数" class="headerlink" title="重定向 printf 函数"></a>重定向 printf 函数</h2><p>对于STM32来说现在串口例程一般都配有一个printf重定向到串口1的代码，直接可以使用printf很方便的输出信息到串口上。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重定义fputc函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> ch, FILE *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>((USART1-&gt;SR&amp;<span class="number">0X40</span>)==<span class="number">0</span>);<span class="comment">//循环发送,直到发送完毕</span></span><br><span class="line">    USART1-&gt;DR = (u8) ch;</span><br><span class="line">  <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="自定义printf函数"><a href="#自定义printf函数" class="headerlink" title="自定义printf函数"></a>自定义printf函数</h2><p>但是我们如果使用多个串口或者说串口输出不一定总从串口1输出怎么办呢。这时候这样就没法实现，后来上网查一下我们可以自己实现printf这个函数。命名为uprintf，接收至少两个参数，第1个参数是串口号;第2个是格式化字符串;第3-n ‘ … ‘ 是参数匹配列表， 实现变长的参数列表接收。。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用串口写一个printf函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uprintf</span><span class="params">(USART_TypeDef *USARTx, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list ap; <span class="comment">//typedef char *va_list; va_list是char型的指针</span></span><br><span class="line">    <span class="keyword">char</span> *s_string = <span class="built_in">malloc</span>(<span class="number">300</span>); <span class="comment">//申请缓冲区</span></span><br><span class="line">    va_start(ap, fmt); <span class="comment">//找第一个可变形参的地址，并把地址赋给ap</span></span><br><span class="line">    <span class="built_in">vsprintf</span>(s_string, fmt, ap); <span class="comment">//类似sprintf函数</span></span><br><span class="line">    USART_String(USARTx, s_string); <span class="comment">//发送和整个字符串</span></span><br><span class="line">    va_end(ap); <span class="comment">//结束</span></span><br><span class="line">    <span class="built_in">free</span>(s_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面这个函数里的过程:</p><ol><li>通过 va_start 函数获得参数列表里每个项和格式化字符里对应的位置，形成一个列表 ap 。</li><li>通过 vsprintf 把列表里每个参数转为字符串写到 s_string 字符串里。</li><li>通过 USART_String 发送到串口。</li><li>释放列表 ap 和 发送缓冲 s_string 。</li></ol><h2 id="完整的一个自定义printf实现文件"><a href="#完整的一个自定义printf实现文件" class="headerlink" title="完整的一个自定义printf实现文件"></a>完整的一个自定义printf实现文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"uart_x.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdarg.h"</span></span></span><br><span class="line"><span class="comment">//发送一个字节</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendByte</span><span class="params">(USART_TypeDef *USARTx, <span class="keyword">unsigned</span> <span class="keyword">char</span> dat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>((USARTx-&gt;SR &amp; <span class="number">0X40</span>) == <span class="number">0</span>) &#123;&#125;; <span class="comment">//循环发送,直到发送完毕</span></span><br><span class="line">    USARTx-&gt;DR = (u8) dat;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发送一个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_String</span><span class="params">(USART_TypeDef *USARTx, <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*s != <span class="string">'\0'</span>)<span class="comment">// '\0' 表示字符串结束标志</span></span><br><span class="line">    &#123;</span><br><span class="line">        SendByte(USARTx, *s);</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用串口写一个printf函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uprintf</span><span class="params">(USART_TypeDef *USARTx, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list ap; <span class="comment">//typedef char *va_list; va_list是char型的指针</span></span><br><span class="line">    <span class="keyword">char</span> *s_string = <span class="built_in">malloc</span>(<span class="number">300</span>); <span class="comment">//申请空间</span></span><br><span class="line">    va_start(ap, fmt); /找第一个可变形参的地址，并把地址赋给ap</span><br><span class="line">    <span class="built_in">vsprintf</span>(s_string, fmt, ap); <span class="comment">//类似sprintf函数</span></span><br><span class="line">    USART_String(USARTx, s_string);  <span class="comment">//发送和整个字符串</span></span><br><span class="line">    va_end(ap); <span class="comment">//结束</span></span><br><span class="line">    <span class="built_in">free</span>(s_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数已经能满足多个串口同时使用printf，根据自己的需求可以修改申请的缓冲区大小即可。</p><h2 id="安全版本的自定义-printf-实现"><a href="#安全版本的自定义-printf-实现" class="headerlink" title="安全版本的自定义 printf 实现"></a>安全版本的自定义 printf 实现</h2><p>但上面的实现并不是安全的，如果你发送的字符串长度大于缓冲区长度就会造成内存溢出。所以你可以更改为一个安全的版本，接收一个缓冲区长度参数从而申请一个合适大小的空间。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用串口写一个printf函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uprintf_s</span><span class="params">(USART_TypeDef *USARTx, <span class="keyword">uint32_t</span> BuffSize,<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list ap; <span class="comment">//typedef char *va_list; va_list是char型的指针</span></span><br><span class="line">    <span class="keyword">char</span> *s_string = <span class="built_in">malloc</span>(BuffSize); <span class="comment">//申请空间</span></span><br><span class="line">    va_start(ap, fmt); <span class="comment">//找第一个可变形参的地址，并把地址赋给ap</span></span><br><span class="line">    vsprintf_s(s_string,BuffSize, fmt, ap);<span class="comment">//类似sprintf_s函数</span></span><br><span class="line">    USART_String(USARTx, s_string); <span class="comment">//发送和整个字符串</span></span><br><span class="line">    va_end(ap); <span class="comment">//结束</span></span><br><span class="line">    <span class="built_in">free</span>(s_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ol><li>使用 printf 大法非常方便，但是尽量避免在中断里调用该函数(执行 printf 需要的时间比较久),以及调试完毕之后注释掉相关的代码，缩短功能代码的执行时间。</li><li>有兴趣的可以写 printf 到 OLED 之类的函数，原理都是一样，实现屏幕位置控制和最后的写一个字节的函数就能完成移植。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;硬件的调试通常可分为两大类，一种是用调试器将芯片和电脑连接通过单步等方式逐步运行进行调试，另一种就是printf大法在程序运行过程中输出调试信息。第一种比较深入，可以了解每一个变量，栈堆，函数等等的变化是比较系统化的调试。但我通常都是用printf来调试的，因为快速简单属于非介入的方式，调试完毕直接注释掉相关部分就行了。&lt;/p&gt;
&lt;h2 id=&quot;重定向-printf-函数&quot;&gt;&lt;a href=&quot;#重定向-printf-函数&quot; class=&quot;headerlink&quot; title=&quot;重定向 printf 函数&quot;&gt;&lt;/a&gt;重定向 printf 函数&lt;/h2&gt;&lt;p&gt;对于STM32来说现在串口例程一般都配有一个printf重定向到串口1的代码，直接可以使用printf很方便的输出信息到串口上。&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//重定义fputc函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fputc&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ch, FILE *f)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;((USART1-&amp;gt;SR&amp;amp;&lt;span class=&quot;number&quot;&gt;0X40&lt;/span&gt;)==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//循环发送,直到发送完毕&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    USART1-&amp;gt;DR = (u8) ch;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ch;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="STM32" scheme="http://begild.top/categories/STM32/"/>
    
    
      <category term="串口(UART)" scheme="http://begild.top/tags/%E4%B8%B2%E5%8F%A3-UART/"/>
    
  </entry>
  
  <entry>
    <title>SMT32串口接收、空闲中断</title>
    <link href="http://begild.top/2018/03/01/STM32-UART-IDLE-IT-md/"/>
    <id>http://begild.top/2018/03/01/STM32-UART-IDLE-IT-md/</id>
    <published>2018-03-01T07:20:12.000Z</published>
    <updated>2018-03-01T12:23:02.921Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="识别尾进行接收结束的验证"><a href="#识别尾进行接收结束的验证" class="headerlink" title="识别尾进行接收结束的验证"></a>识别尾进行接收结束的验证</h2><ol><li>串口接收完毕标志可以利用识别特定字符(字符串)来检测，比如 “\r\n”、’*#’ 之类的。所以每次发数据都需要加上这些字符才能被识别为接收完毕，这样好处就是比较通用。无论是什么硬件平台都能用。代码也不复杂，在STM32平台上简单的例子如下代码段：当接收到 ‘*‘ 时候就会置位接收完成标志位，就可以进行处理了。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXUSART1BUFSIZE 200</span></span><br><span class="line"><span class="keyword">uint8_t</span> Uart1_BUF[MAXUSART1BUFSIZE];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART1_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">//串口1中断服务程序               </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> RecByte;</span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">uint32_t</span> pos = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)  </span><br><span class="line">  &#123;</span><br><span class="line">    RecByte = USART1-&gt;DR;<span class="comment">//读取接收到的数据</span></span><br><span class="line">    <span class="keyword">if</span>(pos &lt; MAXUSART1BUFSIZE)<span class="comment">//防止内存溢出</span></span><br><span class="line">      Uart1_BUF[pos++] = RecByte;</span><br><span class="line">    <span class="keyword">if</span>(RecByte == <span class="string">'*'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//<span class="doctag">TODO:</span> 接收完毕相关处理</span></span><br><span class="line">      pos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><h2 id="识别头尾进行数据段的保护"><a href="#识别头尾进行数据段的保护" class="headerlink" title="识别头尾进行数据段的保护"></a>识别头尾进行数据段的保护</h2><ol><li>上面的方法就是发送的时候麻烦一点，每次都需要在后面加 ‘*‘, 并且如果发送错一次(忘记加 ‘*’)就会把缓冲区的内容累计到下一次(可以添加头识别进行解决)。这样就只会识别指定的数据段。一般这样适用于发送带有意义的控制数据保证数据不多收也不少收。验证的字符要保证不会出现在内容里，或者用多个字符进行验证。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXUSART1BUFSIZE 200</span></span><br><span class="line"><span class="keyword">uint8_t</span> Uart1_BUF[MAXUSART1BUFSIZE];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART1_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">//串口1中断服务程序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> RecByte;</span><br><span class="line">    <span class="keyword">static</span>  <span class="keyword">uint32_t</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)  <span class="comment">//接收中断(接收到的数据必须是0x0d 0x0a结尾)</span></span><br><span class="line">    &#123;</span><br><span class="line">        RecByte = USART1-&gt;DR;<span class="comment">//读取接收到的数据</span></span><br><span class="line">        <span class="keyword">if</span>(RecByte == <span class="string">'#'</span>)</span><br><span class="line">            pos = <span class="number">1</span>; <span class="comment">//开始接收数据</span></span><br><span class="line">        <span class="keyword">if</span>(pos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pos &lt; MAXUSART1BUFSIZE)<span class="comment">//防止内存溢出</span></span><br><span class="line">                Uart1_BUF[pos - <span class="number">1</span>] = RecByte;</span><br><span class="line">            pos ++;</span><br><span class="line">            <span class="keyword">if</span>(RecByte == <span class="string">'*'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//<span class="doctag">TODO:</span> 接收完毕相关处理</span></span><br><span class="line">                pos = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="STM32空闲中断的配置"><a href="#STM32空闲中断的配置" class="headerlink" title="STM32空闲中断的配置"></a>STM32空闲中断的配置</h2><ol><li><p>前几天做项目也要用到串口传输控制信息在STM32上的话可以利用串口空闲中断(接收完字符以后在下一个传输字符的时间内没有字符传来)来接收数据，这样就不用像上面那样做特定的识别，也比较方便。在这里备注一下，因为当时一开始配置完了并不起作用，后来上网查证了最后才找到解决办法。初始化的代码就不贴了，主要是最后配置完毕，开中断的代码贴一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...上续初始化的相关配置</span><br><span class="line">USART_Init(USART1, &amp;USART_InitStructure); <span class="comment">//初始化串口</span></span><br><span class="line">USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);<span class="comment">//开启中断</span></span><br><span class="line">USART_ITConfig(USART1, USART_IT_IDLE,ENABLE);<span class="comment">//开启中断</span></span><br><span class="line"><span class="comment">//USART_ClearITPendingBit(USART1, USART_IT_IDLE |USART_IT_RXNE);//清除中断</span></span><br><span class="line">USART_Cmd(USART1, ENABLE);                    <span class="comment">//使能串口</span></span><br></pre></td></tr></table></figure></li><li><p>一开始我使用的是下面这条语句进行中断配置的，发现并不能触发空闲中断，后来才知道<font color="#ff0000" size="5">必须要分两次</font>才能正确配置:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USART_ITConfig(USART1, USART_IT_RXNE | USART_IT_IDLE, ENABLE);<span class="comment">//开启中断</span></span><br></pre></td></tr></table></figure></li><li><p>查看了一下<font color="#00cccc" size="5">USART_ITConfig()</font>函数的源码才看出来，他这个函数为了USART_IT_IDLE等中断宏定义的通用性，必须每次只能初始化一个中断标志。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_ITConfig</span><span class="params">(USART_TypeDef *USARTx, <span class="keyword">uint16_t</span> USART_IT, FunctionalState NewState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">....</span><br><span class="line">    <span class="comment">/* Get the interrupt position */</span></span><br><span class="line">    itpos = USART_IT &amp; IT_Mask;</span><br><span class="line">    itmask = (((<span class="keyword">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; itpos);</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*相关计算</span></span><br><span class="line"><span class="comment">#define USART_IT_IDLE      ((uint16_t)0x0424)</span></span><br><span class="line"><span class="comment">#define IT_Mask            ((uint16_t)0x001F)  //!&lt; USART Interrupt Mask </span></span><br><span class="line"><span class="comment">itpos = 0x0424 &amp; 0x001F = 0x04;</span></span><br><span class="line"><span class="comment">itmask = (((uint32_t)0x01) &lt;&lt; itpos) = 0x10;</span></span><br><span class="line"><span class="comment">0x10 = 0b00010000//bit[4];</span></span><br><span class="line"><span class="comment">查阅官方的手册可以看到空闲中断使能也恰好就是bit[4];</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>究其原因是因为itmask这个变量其实就是中断位于寄存器的位置，他是一个0bxx1xx的变量。只能表示一个中断标志位所以每次只能初始化一个标志位。</p></li></ol><h2 id="STM32空闲中断服务函数"><a href="#STM32空闲中断服务函数" class="headerlink" title="STM32空闲中断服务函数"></a>STM32空闲中断服务函数</h2><ol><li><p>接下来就是中断服务函数了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> USART1RecBuf[USART1RecBufMaxSize];<span class="comment">//接收缓冲区</span></span><br><span class="line"><span class="keyword">uint8_t</span> sdfsdf = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART1_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span>      <span class="comment">//串口1中断服务程序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uint16_t</span> pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART1, USART_IT_IDLE) != RESET) <span class="comment">//接收完毕触发空闲中断</span></span><br><span class="line">    &#123;</span><br><span class="line">      pos = <span class="number">0</span>;</span><br><span class="line">      USART1-&gt;DR;<span class="comment">//清除空闲中断标志位</span></span><br><span class="line">      <span class="comment">//<span class="doctag">TODO:</span> 中断接收完成标志</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> RecByte;</span><br><span class="line">        Res = USART1-&gt;DR; <span class="comment">//读取接收到的数据</span></span><br><span class="line">        <span class="keyword">if</span>(pos &gt;= USART1RecBufMaxSize) <span class="comment">//超过范围返回</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        USART1RecBuf[pos++] = RecByte;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这里需要注意的就是空闲中断的清除并不是调用USART_ClearITPendingBit()函数来清除,查看库的函数源码实现也可以看到注释里并没有说明 USART_IT_IDLE 该参数是可以被传入的，并且我们使用 <font color="#00cccc" size="3">USART1-&gt;DR</font> 就能清除串口空闲中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">  * @param  USART_IT: specifies the interrupt pending bit to clear.</span></span><br><span class="line"><span class="comment">  *   This parameter can be one of the following values:</span></span><br><span class="line"><span class="comment">  *     @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)</span></span><br><span class="line"><span class="comment">  *     @arg USART_IT_LBD:  LIN Break detection interrupt</span></span><br><span class="line"><span class="comment">  *     @arg USART_IT_TC:   Transmission complete interrupt.</span></span><br><span class="line"><span class="comment">  *     @arg USART_IT_RXNE: Receive Data register not empty interrupt.</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_ClearITPendingBit</span><span class="params">(USART_TypeDef *USARTx, <span class="keyword">uint16_t</span> USART_IT)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">····</span><br></pre></td></tr></table></figure></li><li><p>到此完成了串口空闲中断的配置，之后只要两次接收数据之间的时间大于一个字符的时间(跟波特率有关),就能触发这个中断。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;识别尾进行接收结束的验证&quot;&gt;&lt;a href=&quot;#识别尾进行接收结束的验证&quot; class=&quot;headerlink&quot; title=&quot;识别尾进行接收结束的验证&quot;&gt;&lt;/a&gt;识别尾进行接收结束的验证&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;串口接收完毕标志可以利用识别特定字符(字符串)来检测，比如 “\r\n”、’*#’ 之类的。所以每次发数据都需要加上这些字符才能被识别为接收完毕，这样好处就是比较通用。无论是什么硬件平台都能用。代码也不复杂，在STM32平台上简单的例子如下代码段：当接收到 ‘*‘ 时候就会置位接收完成标志位，就可以进行处理了。&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; MAXUSART1BUFSIZE 200&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;uint8_t&lt;/span&gt; Uart1_BUF[MAXUSART1BUFSIZE];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;USART1_IRQHandler&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt; 	&lt;span class=&quot;comment&quot;&gt;//串口1中断服务程序               &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;uint8_t&lt;/span&gt; RecByte;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt;  &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt; pos = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RecByte = USART1-&amp;gt;DR;&lt;span class=&quot;comment&quot;&gt;//读取接收到的数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(pos &amp;lt; MAXUSART1BUFSIZE)&lt;span class=&quot;comment&quot;&gt;//防止内存溢出&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Uart1_BUF[pos++] = RecByte;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(RecByte == &lt;span class=&quot;string&quot;&gt;&#39;*&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;//&lt;span class=&quot;doctag&quot;&gt;TODO:&lt;/span&gt; 接收完毕相关处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      pos = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="STM32" scheme="http://begild.top/categories/STM32/"/>
    
    
      <category term="串口(UART)" scheme="http://begild.top/tags/%E4%B8%B2%E5%8F%A3-UART/"/>
    
  </entry>
  
  <entry>
    <title>ESP8266工程的裁剪和编译</title>
    <link href="http://begild.top/2018/01/23/ESP8266%E5%B7%A5%E7%A8%8B%E7%9A%84%E8%A3%81%E5%89%AA%E5%92%8C%E7%BC%96%E8%AF%91/"/>
    <id>http://begild.top/2018/01/23/ESP8266工程的裁剪和编译/</id>
    <published>2018-01-23T08:35:39.000Z</published>
    <updated>2018-03-01T03:26:33.495Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇文章主要讲一下，乐鑫官方给的ESP8266 Demo怎么裁剪成我们要的样子以及编译。</p><h2 id="模板工程所需文件"><a href="#模板工程所需文件" class="headerlink" title="模板工程所需文件"></a>模板工程所需文件</h2><p>由于官方给的工程是包含了全部的Demo和库所以我们直接使用是不能编译的。我们就从一个最基础的工程模板开始裁剪，因为其他的功能都可以通过工程模板添加库和代码来实现。首先亮一下官方原版的RTOS SDK的工程结构(下左图)。<br><a id="more"></a><br><img src="https://s1.ax1x.com/2018/01/23/pIQc7j.png" alt="1.png">  </p><p>我们需要把这个工程做成一个最基本的模板那么就需要把里面冲突的和暂时不需的都给删除。如下图是需要裁剪的内容： 红色的是需要删除的。紫色的删了节省空间。<br><img src="https://s1.ax1x.com/2018/01/23/pI1hOU.png" alt="2.png"><br>所以我们把刚刚标记这些都全部删除(别忘了备份一个原版的以后用)之后，这样就会少了很多东西。<br>那现在可以编译了吗？打扰了，并不行。因为makefile这个神奇的东西存在，所以我们需要做一些调整和更改使得makefile能正确的识别、编译、链接整个工程。至于makefile是什么东西大家上网搜查看！这里就不展开讲了，因为就那个就可以做一个专题23333。<br>你暂时只需要知道编译整个工程需要它掌控整个工程的各个文件的信息和关系的，所以我们需要告诉它各个文件的信息和之间的关系，所幸的是官方给的makefile已经很通用了，我们稍微做改变就可以了(感谢ing…)</p><h2 id="模板工程文件的调整"><a href="#模板工程文件的调整" class="headerlink" title="模板工程文件的调整"></a>模板工程文件的调整</h2><p>下面的操作就是属于比较灵性的，不要问我为什么因为我个人觉得这样比较好。先按照我的来，等你学会了就可以去装逼了。先约定”/“就是工程的根目录，用绝对路径目录有点长。  </p><ol><li>剪切 /driver_lib/driver —&gt; /examples/project_template/</li><li>剪切 /driver_lib/include/ 的所有头文件 —&gt; /examples/project_template/include/</li><li>改名 /examples/project_template —&gt; app</li><li>复制 /examples/app —&gt; /</li><li>删除 /app/sample_lib 目录</li><li>删除 /driver_lib 目录  </li><li>删除 /examples 目录</li></ol><p>这样就完成了工程文件的调整：把相关的硬件驱动移到app目录下面，并且删除了示例的库。调整完成之后的目录如下图(documents目录删不删不影响)：<br><img src="https://s1.ax1x.com/2018/01/23/pouGqJ.png" alt="3.png">  </p><h2 id="MakeFile文件的修改"><a href="#MakeFile文件的修改" class="headerlink" title="MakeFile文件的修改"></a>MakeFile文件的修改</h2><ol><li>修改/Makefile文件<ul><li>文件里添加两句话<font color="#ff0000" size="5">SDK_PATH=××× BIN_PATH=xxx </font>比如我的工程根目录在<font color="#00ccff" size="3"> “ e:/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template “</font>那么我的文件修改如下：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line"><span class="keyword">ifndef</span> PDIR</span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">SDK_PATH=e:/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template</span><br><span class="line">BIN_PATH=e:/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/bin</span><br><span class="line"> </span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(COMPILE)</span>, xcc)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>2.修改/app/Makefile文件</p><ul><li>文件里添加一句话<font color="#ff0000" size="5">SDK_PATH=×××</font> 添加在文件的17行左右，内容就是你工程的根目录。</li><li>文件里的<font color="#ff0000" size="5">SUBDIR=×××</font> 把所有包含了c文件的子目录都添加进去。(‘\’表示续一行)，ctrl+f可快速查找，修改位置大概在23行左右。</li><li><p>修改完成之后如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...上续</span><br><span class="line"><span class="comment">#FLAVOR = release</span></span><br><span class="line">FLAVOR = debug</span><br><span class="line">SDK_PATH=e:/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template</span><br><span class="line"><span class="comment">#EXTRA_CCFLAGS += -u</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifndef</span> PDIR <span class="comment"># &#123;</span></span><br><span class="line">GEN_IMAGES= eagle.app.v6.out</span><br><span class="line">GEN_BINS= eagle.app.v6.bin</span><br><span class="line">SPECIAL_MKTARGETS=<span class="variable">$(APP_MKTARGETS)</span></span><br><span class="line">SUBDIRS=    \</span><br><span class="line">    user    \</span><br><span class="line">    driver</span><br><span class="line"><span class="keyword">endif</span> <span class="comment"># &#125; PDIR</span></span><br><span class="line">...下续</span><br></pre></td></tr></table></figure></li><li><p>把<font color="#ff0000" size="5">COMPONENTS_eagle.app.v6=×××</font> 需要的.a文件修改为子目录下生成对应的.a文件(听不懂没关系，看效果代码)，大概在48行左右。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...上续</span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(FLAVOR)</span>,release)</span><br><span class="line">TARGET_LDFLAGS += -g -O0</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">COMPONENTS_eagle.app.v6 = \</span><br><span class="line">    user/libuser.a  \</span><br><span class="line">    driver/libdriver.a </span><br><span class="line">LINKFLAGS_eagle.app.v6 = \</span><br><span class="line">    -L<span class="variable">$(SDK_PATH)</span>/lib        \</span><br><span class="line">    -Wl,--gc-sections   \</span><br><span class="line">...下续</span><br></pre></td></tr></table></figure></li></ul><p>这样就修改完成了。  </p><h2 id="工程的编译"><a href="#工程的编译" class="headerlink" title="工程的编译"></a>工程的编译</h2><ol><li>左键点击工程名选中工程-&gt;右键弹出菜单-&gt;BuildProject 即可编译。如果出现BuildProject选项灰色就是你没选中。如果失败可以尝试CleanProject(就在BuildProject下面)一下工程再编译。</li><li>编译之后输出窗口大致如下，输出两个bin文件：eagle.flash.bin 和 eagle.irom0text.bin ,这样就完成了工程的编译。这个固件是不支持OTA升级的，所以也不需要boot。也没有user1.bin和user2.bin。所以不要觉得奇怪。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">23:48:32 **** Incremental Build of configuration Default for project ESP8266_RTOS_SDK-1.5-project_template ****</span><br><span class="line">make all </span><br><span class="line">make[1]: Entering directory &apos;/cygdrive/e/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/app&apos;</span><br><span class="line">make[2]: Entering directory &apos;/cygdrive/e/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/app/user&apos;</span><br><span class="line">make[2]: Leaving directory &apos;/cygdrive/e/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/app/user&apos;</span><br><span class="line">make[2]: Entering directory &apos;/cygdrive/e/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/app/driver&apos;</span><br><span class="line">make[2]: Leaving directory &apos;/cygdrive/e/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/app/driver&apos;</span><br><span class="line"></span><br><span class="line">!!!</span><br><span class="line">SDK_PATH: e:/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template</span><br><span class="line">BIN_PATH: e:/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/bin</span><br><span class="line"></span><br><span class="line">No boot needed.</span><br><span class="line">Generate eagle.flash.bin and eagle.irom0text.bin successully in BIN_PATH</span><br><span class="line">eagle.flash.bin--------&gt;0x00000</span><br><span class="line">eagle.irom0text.bin----&gt;0x20000</span><br><span class="line">!!!</span><br><span class="line">make[1]: Leaving directory &apos;/cygdrive/e/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/app&apos;</span><br><span class="line"></span><br><span class="line">23:48:37 Build Finished (took 4s.472ms)</span><br></pre></td></tr></table></figure></li></ol><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这篇说的可能看起来有点云里雾里。因为和平时大家用的的不需要自己编写编译规则的IDE不同。像keil的话你添加的头文件也需要的手动添加到工程的IncludePath里面去。但是用这个eclipse开发esp8266完全使用makefile控制的，你的目录，头文件，c文件都是需要你手动配置makefile的，道理都一样都是要告诉编译器怎么去编译链接文件。不过是你自己找到makefile添加而已。之后会专门有一篇大概说一下整个工程如果我们想添加新的功能文件夹(比如实现一个tcp客户端功能)，我们怎么去修改makefile。有什么疑问欢迎联系我。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇文章主要讲一下，乐鑫官方给的ESP8266 Demo怎么裁剪成我们要的样子以及编译。&lt;/p&gt;
&lt;h2 id=&quot;模板工程所需文件&quot;&gt;&lt;a href=&quot;#模板工程所需文件&quot; class=&quot;headerlink&quot; title=&quot;模板工程所需文件&quot;&gt;&lt;/a&gt;模板工程所需文件&lt;/h2&gt;&lt;p&gt;由于官方给的工程是包含了全部的Demo和库所以我们直接使用是不能编译的。我们就从一个最基础的工程模板开始裁剪，因为其他的功能都可以通过工程模板添加库和代码来实现。首先亮一下官方原版的RTOS SDK的工程结构(下左图)。&lt;br&gt;
    
    </summary>
    
      <category term="ESP8266" scheme="http://begild.top/categories/ESP8266/"/>
    
    
  </entry>
  
  <entry>
    <title>ESP8266工程的导入</title>
    <link href="http://begild.top/2018/01/22/ESP8266%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%AF%BC%E5%85%A5/"/>
    <id>http://begild.top/2018/01/22/ESP8266工程的导入/</id>
    <published>2018-01-22T12:32:57.000Z</published>
    <updated>2018-03-01T03:30:51.422Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>本篇文章主要讲一下，ESP8266的工程怎么导入到Eclipse里。</p><h2 id="准备一个SDK工程"><a href="#准备一个SDK工程" class="headerlink" title="准备一个SDK工程"></a>准备一个SDK工程</h2><ul><li>既然是导入那么你首先得有一个现有的工程(不存在建工程的，这辈子都不可能徒手建工程的)，工程从网上找一个就OK了。</li><li>ESP8266的SDK有两种，一种是无系统(NON-OS SDK)，另一种是运行了FreeRTOS的(RTOS SDK)。</li></ul><a id="more"></a><table><tr><th width="15%">SDK类型</th><th width="55%">描述</th><th width="30%">优缺点</th></tr><tr><td>NOn-OS SDK</td><td>1.主要使⽤定时器和回调函数的⽅式实现各个功能事件的嵌套，达到特定条件下触发特定功能函数的⽬的。<br>2.使⽤ espconn 接⼝实现⽹络操作，⽤户需要按照 espconn 接⼝的使⽤规则进⾏软件开发.</td><td>1.无系统，顺序执行好理解占用资源少，但是不能有while(1);<br>2.不能有超过10ms的阻塞(延时)发生，否则将会重启。</td></tr><tr><td>RTOS SDK</td><td>1.用户可以使⽤FreeRTOS 的标准接⼝实现资源管理、循环操作、任务内延时、任务间信息传递和同步等⾯向任务流程的设计⽅式;<br>2.⽹络操作接⼝是标准 lwIP API，同时提供了 BSD Socket API 接⼝的封装实现，⽤户可以直接按照 Socket API 的使⽤⽅式来开发软件应⽤，也可以直接编译运⾏其他平台的标准 Socket 应⽤; <br>3.引⼊了 cJSON 库，使⽤该库函数可以更加⽅便的实现对 JSON 数据包的解析;<br>4.兼容 non-OS SDK 中的 Wi-Fi 接⼝、SmartConfig 接⼝、Sniffer 相关接⼝、系统接⼝、定时器接⼝、FOTA 接⼝和外围驱动接⼝，不⽀持 AT 实现。</td><td>1.有系统，通过任务的调度完成系统的运行，可以有延时。<br>2.但是资源占用较多。</td></tr></table> <ul><li>例子可以从乐鑫官方的<a href="http://espressif.com/zh-hans/support/download/sdks-demos" target="_blank" rel="noopener">下载地址</a>下载.在下图所在的网页上面有选项选择ESP8266EX之后可以从下图所示的界面选择你所需要的SDK。<br><img src="https://s1.ax1x.com/2018/01/22/p4Iub8.md.png" alt="乐鑫SDK下载"></li><li>点击右边的下载按钮会跳转到GitHub(需要你懂一点点的git的知识才能下载)。如果实在没办法的话(求求你学一点git吧)，我把我写文章的时候的最新的上传到网盘，大家可以去下载 链接: <a href="https://pan.baidu.com/s/1c39VpXQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1c39VpXQ</a> 密码: dup8 。</li><li>下载下来解压到你想放置的目录，不要有中文和(空格?)，这样工程就完成了初步的布置。接下来就是重头戏了。<h2 id="导入工程"><a href="#导入工程" class="headerlink" title="导入工程"></a>导入工程</h2></li><li>第一步:应该能想到吧，那就是打开Eclipe_IDE(不会打开就算了你不适合用电脑)。</li><li>第二步:打开eclipse之后会出现欢迎界面:”Welcome to the Eclipse IDE for C/C++ Developers”。</li><li>第三步:点击 工具栏-&gt;File-&gt;Import (如图)进入导入工程窗口。<br><img src="https://s1.ax1x.com/2018/01/22/p5SChq.png" alt="导入工程1"></li><li>第四步:在select窗口选择C/C++-&gt;Existing Code as Makefile Project-&gt;点击Next进行下一步<br><img src="https://s1.ax1x.com/2018/01/22/p5ptMT.png" alt="导入工程2"></li><li>第五步:Import Existing Code 窗口选择浏览你的工程路径(就是解压出来的文件的路径)-&gt;下方选择 Cygwin GCC 工具-&gt;再点击Finish按钮完成导入。如果在这一步发现没有Cygwin GCC选项回头去检查是否用Eclipse_IDE.exe选择了正确的 Cygwin 路径。<br><img src="https://s1.ax1x.com/2018/01/23/p5AYtg.png" alt="导入工程3"></li><li>第六步:这时候你会发现，什么都没出现！怎么办？，那就是把欢迎界面叉掉！这样在右边Project栏就能发现一个折叠的工程，点击可以展开，整个界面大致如下图。我的因为是用git直接克隆下来的，所以在工程名旁边会提示橙色的字。如果你是从百度云下载的那就没有，这个无需理会，都一样(牛逼吧，git)。这时候问题输出窗口应该是什么都没有的，如果提示什么找不到g++、make等等，返回去检查是否选择的工具是Cygwin GCC！！！。<br><a href="https://imgchr.com/i/p5ERIS" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/01/23/p5ERIS.png" alt="工程整体结构图"></a><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2>我们都是用别人的工程(Demo)上开发的，所以这一步属于比较基础的，我们导入进来之后应该是编译通不过的！为什么，因为我们的SDK路径和写Demo的人不一样。这个涉及到makefile的编写了，不过别人已经把整个makefile编写的比较”智能”了，我们只是想要编译成功的话其实是不需要懂makefile的。我们改一改SDK的路径就行了。这个下一节再讲。</li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>乐鑫官方的快速上手指导文档在上一篇<esp8266开发环境搭建>-&gt;后记 里有网盘链接在这里就不放了。里面有SDK文件目录的讲解7/31页，看一下便于后面理解。  我整理了一下：  </esp8266开发环境搭建></p><ol><li>RTOS SDK工程目录讲解    <ul><li>bin：编译⽣成的 BIN 文件，可直接下载到 Flash 中。  </li><li>documents：SDK 相关的⽂档(RTOS api)或链接。  </li><li>driver_lib：乐鑫官方提供的驱动示例代码。(IIC SPI GPIO等)  </li><li>examples：可供用户二次开发的示例代码。(我们把不要的删掉)  <ul><li>openssl_demo：乐鑫官方提供的 OpenSSL 接口功能示例代码。  </li><li>project_template：乐鑫官方提供的工程模板示例代码。(我们用这个，其他的以后再说)  </li><li>smart_config：乐鑫官⽅提供的 SmartConfig 功能示例代码。  </li><li>spiffs_test：乐鑫官方提供的 SPIFFS 文件系统功能示例代码。  </li><li>websocket_demo：乐鑫官方提供的 WebSocket 功能示例代码。  </li></ul></li><li>include：SDK 自带头文件，包含了用户可使⽤的相关 API 函数及其他宏定义，用户无需修改。  </li><li>ld：链接时所需的脚本文件，如⽆特殊需求，用户无需修改。(根据这个可以生成多钟bin文件)  </li><li>lib：SDK 提供的库文件。(只能用api不能改不能看)  </li><li>third_party：乐鑫开放源代码的第三方库，当前包含FreeRTOS、JSON、LWIP,mbedTLS、noPoll、OpenSSL、SPIFFS 和 SSL。  </li><li>tools：编译 BIN 文件所需的工程具，用户无需修改。  </li></ul></li><li>Non-OS SDK工程目录讲解  <ul><li>bin：编译⽣成的 BIN 文件，可直接下载到 Flash 中。  </li><li>documents：SDK 相关的⽂档或链接。  </li><li>driver_lib：外设驱动的库文件，如：UART、I2C 和 GPIO 等。  </li><li>examples：可供用户次开发的示例代码，如 IoT Demo 等。   </li><li>include：SDK ⾃带头文件，包含了用户可使用的相关 API 函数及其他宏定义，用户无需修改。  </li><li>ld：链接时所需的脚本文件，若无特殊需求，用户⽆需修改。  </li><li>lib：SDK 提供的库文件。  </li><li>tools：编译 BIN 文件所需的工具，用户无需修改。  </li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h2&gt;&lt;p&gt;本篇文章主要讲一下，ESP8266的工程怎么导入到Eclipse里。&lt;/p&gt;
&lt;h2 id=&quot;准备一个SDK工程&quot;&gt;&lt;a href=&quot;#准备一个SDK工程&quot; class=&quot;headerlink&quot; title=&quot;准备一个SDK工程&quot;&gt;&lt;/a&gt;准备一个SDK工程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;既然是导入那么你首先得有一个现有的工程(不存在建工程的，这辈子都不可能徒手建工程的)，工程从网上找一个就OK了。&lt;/li&gt;
&lt;li&gt;ESP8266的SDK有两种，一种是无系统(NON-OS SDK)，另一种是运行了FreeRTOS的(RTOS SDK)。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="ESP8266" scheme="http://begild.top/categories/ESP8266/"/>
    
    
  </entry>
  
  <entry>
    <title>ESP8266开发环境的搭建</title>
    <link href="http://begild.top/2018/01/21/ESP8266%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>http://begild.top/2018/01/21/ESP8266开发环境的搭建/</id>
    <published>2018-01-21T13:54:35.000Z</published>
    <updated>2018-03-01T03:30:19.464Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>本篇文章主要讲一下，ESP8266的开发环境怎么搭建。</p><h2 id="开发工具下载"><a href="#开发工具下载" class="headerlink" title="开发工具下载:"></a>开发工具下载:</h2><p>对于ESP8266的开发工具我们采用的是eclipse搭建的一个IDE。这是安信可公司开发出来的，他们公司还出了一款付费的，只需要点一点就能生成基础代码的工具(不付费只能生成代码不能编译)。<a href="http://pan.baidu.com/s/1skRvR1j" target="_blank" rel="noopener">点击这里</a>下载最新的IDE。这里最新更新是2016年，应该已经停止了更新。防止链接失效，我转存到我的网盘：<a href="https://pan.baidu.com/s/1c3OitUw" target="_blank" rel="noopener">ESP8266开发环境</a> 密码: qnkh。如果我的失效了请联系我更换。</p><h2 id="开发环境搭建步骤"><a href="#开发环境搭建步骤" class="headerlink" title="开发环境搭建步骤"></a>开发环境搭建步骤</h2><p>当你忍受了百度云限速下载完成后恭喜你最<font color="#00ffff" size="5">艰难</font>的一步完成！下载之后的会有四个文件：<br><a id="more"></a><br>文件     |说明<br>—    |—<br>cygwin.exe | cygwin和xtensa编译器环境<br>Eclipse.exe | eclipse c/c++ 开发工具打包<br>ESP_IDE.exe | 一体化开发环境(配置)工具<br>下载前读我！！！.txt|就是说明文档和教程(我的教程意义何在!!!)</p><ol><li>我们要把下载的文件放到你想要放的位置该位置必须<font color="#ff0000" size="5">不能有空格</font>(cygwin目录不能有空格)，我一开始放在了放在了”D:\Program Files\ESP8266IDE\” 目录下导致后面没法选择 cygwin。最后我选择放在 “D:\ESP8266IDE\”，</li><li>点击打开cygwin.exe和Eclipse.exe进行自解压到当前目录，解压完成之后会在生成两个目录，”cygwin 和 eclipse”。</li><li>点击ESP_IDE.exe运行，选择cygwin目录和eclipse目录。同时右下角的Not Ask也勾选，这样下次就不会再次弹出来让你选择path。如果出问题了删除ESP_IDE.exe同级目录-&gt;config-&gt;cfg.xml，再次打开就会提示你选择。<br><img src="https://s1.ax1x.com/2018/01/21/pfHHkF.png" alt="选择工具路径"></li><li>首次运行会提示选择工作空间的路径。自己建一个目录选择就OK了,我选择”D:\ESP8266IDE\workspaces”,勾选下面的选项下次就不会弹出来让你选了。(备注：一个工作空间可以同时打开很多个工程，不是每一个工程都需要打开一次IDE)。<br><img src="https://s1.ax1x.com/2018/01/21/pfHbY4.png" alt="选择工作空间">  </li></ol><h2 id="完成搭建"><a href="#完成搭建" class="headerlink" title="完成搭建"></a>完成搭建</h2><p>这样就完成了开发环境的配置了，是不是感觉有点简单的过分。把cygwin.exe、Eclipse.exe删除节省空间。最后，别忘了把ESP_IDE.exe创建一个快捷方式到桌面(不懂的…)，这样你下次直接点击就能打开eclipseIDE了。  </p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ol><li>还有另外一种使用ubuntu镜像进行编译的方式，不过没有这种方便所以就不介绍了(官方有一个文档可自行去乐鑫下载也可下载我上传到网盘的链接:<a href="https://pan.baidu.com/s/1ggMazRl" target="_blank" rel="noopener">https://pan.baidu.com/s/1ggMazRl</a> 密码: g3y3 ,在第9/31页开始讲。所以感谢<a href="https://www.ai-thinker.com" target="_blank" rel="noopener">安信可公司</a>的奉献，让我们可以省去使用官方ubuntu镜像编译的开发方式！撒花ing…</li><li>arduino IDE工具，这个也可以开发，不过我并不喜欢arduino所以我一眼都没看过23333。  </li></ol><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ol><li>乐鑫公司官方文档资料、工具、demo下载地址:<a href="http://espressif.com/zh-hans/support/download/overview" target="_blank" rel="noopener">http://espressif.com/zh-hans/support/download/overview</a>.</li><li>安信可公司官方的资料地址:<a href="http://wiki.ai-thinker.com/esp8266" target="_blank" rel="noopener">http://wiki.ai-thinker.com/esp8266</a>.</li><li>开发快公司提供免费的ESP8266模组的申请:<a href="http://bbs.kaifakuai.com/thread-981-1-1.html" target="_blank" rel="noopener">http://bbs.kaifakuai.com/thread-981-1-1.html</a>,注册之后就可以申请(我当时就是因为申请到了才开始玩ESP8266的，虽然很便宜但是抵不住他不要钱啊！！！).当然他们公司资料也很多的也很活跃，大家可以到处逛逛。开发快官方开发平台:<a href="http://developer.kaifakuai.com" target="_blank" rel="noopener">http://developer.kaifakuai.com</a>。QQ群:445880047。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h2&gt;&lt;p&gt;本篇文章主要讲一下，ESP8266的开发环境怎么搭建。&lt;/p&gt;
&lt;h2 id=&quot;开发工具下载&quot;&gt;&lt;a href=&quot;#开发工具下载&quot; class=&quot;headerlink&quot; title=&quot;开发工具下载:&quot;&gt;&lt;/a&gt;开发工具下载:&lt;/h2&gt;&lt;p&gt;对于ESP8266的开发工具我们采用的是eclipse搭建的一个IDE。这是安信可公司开发出来的，他们公司还出了一款付费的，只需要点一点就能生成基础代码的工具(不付费只能生成代码不能编译)。&lt;a href=&quot;http://pan.baidu.com/s/1skRvR1j&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击这里&lt;/a&gt;下载最新的IDE。这里最新更新是2016年，应该已经停止了更新。防止链接失效，我转存到我的网盘：&lt;a href=&quot;https://pan.baidu.com/s/1c3OitUw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ESP8266开发环境&lt;/a&gt; 密码: qnkh。如果我的失效了请联系我更换。&lt;/p&gt;
&lt;h2 id=&quot;开发环境搭建步骤&quot;&gt;&lt;a href=&quot;#开发环境搭建步骤&quot; class=&quot;headerlink&quot; title=&quot;开发环境搭建步骤&quot;&gt;&lt;/a&gt;开发环境搭建步骤&lt;/h2&gt;&lt;p&gt;当你忍受了百度云限速下载完成后恭喜你最&lt;font color=&quot;#00ffff&quot; size=&quot;5&quot;&gt;艰难&lt;/font&gt;的一步完成！下载之后的会有四个文件：&lt;br&gt;
    
    </summary>
    
      <category term="ESP8266" scheme="http://begild.top/categories/ESP8266/"/>
    
    
  </entry>
  
  <entry>
    <title>ESP8266开发历程前言</title>
    <link href="http://begild.top/2018/01/21/ESP8266%E5%BC%80%E5%8F%91%E5%89%8D%E8%A8%80/"/>
    <id>http://begild.top/2018/01/21/ESP8266开发前言/</id>
    <published>2018-01-21T06:43:23.000Z</published>
    <updated>2018-03-01T03:28:14.240Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="意义："><a href="#意义：" class="headerlink" title="意义："></a>意义：</h2><p>这算是第一个教程吧，ESP8266从大三到现在学了到现在，但是没有什么记录。回头又得拿着代码一点一点看，所以打算记录一下。同时也会兼顾一些解释和教程性质的东西，给能找到这的人看看吧，希望能给你一点帮助。</p><h2 id="更新："><a href="#更新：" class="headerlink" title="更新："></a>更新：</h2><p>更新的话，不定时。至于内容的顺序，就先按照一个hello world的实现来写，从引脚，IDE，下载工具，接线到写hello world，到下载查看。这些讲完的话打开你也就懂怎么做了。但是我不会写IO的使用因为我觉得他的定位作为wifi芯片比较好，就不要掺杂其他的的东西了(个人看法)。后面的软件层面的实现(主要是网络通信的应用)的话，也会写一部分。不过感觉网上其实挺多的教程(比较零散)，所以不排除会直接把比较好的搬运过来然后配合自己的理解说一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;意义：&quot;&gt;&lt;a href=&quot;#意义：&quot; class=&quot;headerlink&quot; title=&quot;意义：&quot;&gt;&lt;/a&gt;意义：&lt;/h2&gt;&lt;p&gt;这算是第一个教程吧，ESP826
      
    
    </summary>
    
      <category term="ESP8266" scheme="http://begild.top/categories/ESP8266/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux系统目录讲解</title>
    <link href="http://begild.top/2017/12/06/file%20system/"/>
    <id>http://begild.top/2017/12/06/file system/</id>
    <published>2017-12-06T12:45:30.000Z</published>
    <updated>2018-01-20T13:12:24.911Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><h2 id="bin-目录"><a href="#bin-目录" class="headerlink" title="/bin 目录"></a>/bin 目录</h2><ul><li>全称：Binary(Binaries)</li><li>作用：存放二进制可执行文件，例如命令行的cp命令。</li><li>备注：/bin下的命令是所有用户都可以执行的。/sbin(Spuer Binary)目录下的命令只有超级用户权限才能执行，比如分区操作。</li></ul><hr><h2 id="boot-目录"><a href="#boot-目录" class="headerlink" title="/boot 目录"></a>/boot 目录</h2><ul><li>全称 ：Boot</li><li>作用 ：存放操作系统的引导启动需要的文件。一般100M左右(50~200)。</li><li>备注 ：里面存放的vmlinuz…文件就是操作系统的内核文件，他名字就是版本号。通过bash运行 uname -r<br>可以看到系统的版本。grub引导同样在/boot下。</li></ul><hr><h2 id="dev-目录"><a href="#dev-目录" class="headerlink" title="/dev 目录"></a>/dev 目录</h2><ul><li>全称 ：Device</li><li>作用 ：把计算机的硬件抽象为文件存储在/dev下面。诸如硬盘(hd×),处理器(cpu),网卡(net),usb等等。</li></ul><hr><h2 id="etc-目录"><a href="#etc-目录" class="headerlink" title="/etc 目录"></a>/etc 目录</h2><ul><li>全称 ：Etcetera(其他)/Editable Text Configuration(可编辑配置文本)</li><li>作用 ：保存几乎所有的配置文件，系统的各个服务、组件、软件的配置文件存放地方，一般以.cnf或.conf结尾(configure)。</li></ul><hr><h2 id="home-目录"><a href="#home-目录" class="headerlink" title="/home 目录"></a>/home 目录</h2><ul><li>全称 ：Home</li><li>作用 ：存放除root用户之外所有用户的’家目录’的目录。<ul><li>也就是每一个用户都会在/ｈome下有一个对应用户名的目录，用于存放该用户的私有数据。比如系统里有一个begild用户，那么/home下必有一个Beild文件夹。/home/begild下存放自己的桌面、文档等。</li></ul></li></ul><hr><h2 id="lib-目录"><a href="#lib-目录" class="headerlink" title="/lib 目录"></a>/lib 目录</h2><ul><li>全称 ：Library(Libraries)</li><li>作用 ：linux系统运行需要的共享库文件，相当于windows的.DLl文件(动态链接库)。一般以 .so (shared object)结尾。</li><li>备注：同样的还有/lib32、/lib64两个文件夹，作用和/lib相同，只是运用于32位还是64位。</li></ul><hr><h2 id="lost-found-目录"><a href="#lost-found-目录" class="headerlink" title="/lost+found　目录"></a>/lost+found　目录</h2><ul><li>全称 ：lost+found</li><li>作用 ：用于存放系统发生错误的时候遗失的文件。</li><li>备注 ：只有root权限才能访问</li></ul><hr><h2 id="mnt-目录"><a href="#mnt-目录" class="headerlink" title="/mnt 目录"></a>/mnt 目录</h2><ul><li>全称 ：Mount(挂载)</li><li>作用 ：其他文件系统挂载的挂载点。使用mount命令挂载(手动挂载)。</li><li>备注 ：具备同样作用的还有/media目录，不过media目录一般用于实现自动挂载。</li></ul><hr><h2 id="opt-目录"><a href="#opt-目录" class="headerlink" title="/opt　目录"></a>/opt　目录</h2><ul><li>全称 ：Optional application software packages(可选的应用程序)</li><li>作用 ：存放第三方、大型、版权保护的软件、游戏。</li><li>备注 ：安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。</li></ul><hr><h2 id="proc-目录"><a href="#proc-目录" class="headerlink" title="/proc 目录"></a>/proc 目录</h2><ul><li>全称 ：</li><li>作用 ：存放进程信息，内核信息，内存使用等等快速变化的’文件’的目录。</li><li>备注 ：它本身不存在于实际的文件系统里。他是一种虚拟的文件系统。例如我们通过cat /proc/cpuinfo命令可以打开cpuinfo文件。里面完整的描述了cpu的信息。</li></ul><hr><h2 id="root-目录"><a href="#root-目录" class="headerlink" title="/root 目录"></a>/root 目录</h2><ul><li>全称 ：Root</li><li>作用 ：root用户的家目录，其他的用户家目录位于/home下。</li></ul><hr><h2 id="tmp-目录"><a href="#tmp-目录" class="headerlink" title="/tmp 目录"></a>/tmp 目录</h2><ul><li>全称 ：temp</li><li>作用 ：存放系统的临时文件,例如压缩文件预览.关机会自动清理,手动清理用tmpwatch命令.</li></ul><hr><h2 id="usr-目录"><a href="#usr-目录" class="headerlink" title="/usr 目录"></a>/usr 目录</h2><ul><li>全称 ：unix software resource</li><li>作用 ：软件安装的目录.</li></ul><hr><h2 id="var-目录"><a href="#var-目录" class="headerlink" title="/var 目录"></a>/var 目录</h2><ul><li>全称 ：variable</li><li>作用 ：存放系统/软件运行过程中产生的缓存,登录日志等等文件.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;h2 id=&quot;bin-目录&quot;&gt;&lt;a href=&quot;#bin-目录&quot; class=&quot;headerlink&quot; title=&quot;/bin 目录&quot;&gt;&lt;/a&gt;/bin 目录&lt;/h2&gt;
      
    
    </summary>
    
      <category term="linux" scheme="http://begild.top/categories/linux/"/>
    
    
      <category term="linux目录" scheme="http://begild.top/tags/linux%E7%9B%AE%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>C函数指针</title>
    <link href="http://begild.top/2017/10/28/C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
    <id>http://begild.top/2017/10/28/C函数指针/</id>
    <published>2017-10-28T02:59:10.000Z</published>
    <updated>2018-03-03T06:27:52.591Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>当我们看到如下所示的代码怎么去理解它的意义呢。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(* ( <span class="keyword">void</span> (*) () ) <span class="number">0</span>) ()</span><br></pre></td></tr></table></figure></p><p>解析这个函数需要下面几个知识</p><ol><li><p>函数申明包含返回值，函数名，参数列表。</p><ul><li>如返回值是’int’ 函数名为’fun’,参数列表为’void’。</li><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>函数指针和返回值为指针的函数</p><ul><li>函数指针:函数指针pfun指向的是一个返回值为int类型，参数列表为空的函数。只要是符合这个’形状’的函数都可以吧地址赋给pfun。</li><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*pfun) (<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure></li><li><p>返回值为指针的函数:返回值为int*类型的指针，参数列表为空的函数fun1。它表示fun1是一个确定的函数。不像pfun是可以指向任何符合模板的函数。</p></li><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">fun1</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p>所以在书写的时候必须注意是否需要加括号。</p></li><li><p>类型转化符。就像我们平时说的怎么把一个int强制转化为char呢，就是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">48</span>;</span><br><span class="line"><span class="keyword">char</span> b = (<span class="keyword">char</span>) a;</span><br></pre></td></tr></table></figure><p>我们怎么构建一个类型转化符呢，就是把目标类型用括号括起来，那么一个函数模板的类型转化符是怎么样的呢，就是把函数名去掉，然后用括号把他括起来。比如上面的函数指针pfun这个模板。我们只需要将pfun去掉，然后把剩下部分括起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span> (*) (<span class="keyword">void</span>) )</span><br></pre></td></tr></table></figure><p>这就是一个返回值为int参数列表为空的函数指针的强制类型转化符。</p></li></ol><hr><p>完成上述理解之后，我们着手理解一下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(* ( <span class="keyword">void</span> (*) () ) <span class="number">0</span>) ()</span><br></pre></td></tr></table></figure></p><p>首先通过下面这个式子可以看出这是一个函数的调用，那么左括号里面的就是函名。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(       funname     ) ()</span><br></pre></td></tr></table></figure></p><p>也就是 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* (<span class="keyword">void</span> (*) () ) <span class="number">0</span>   == funname</span><br></pre></td></tr></table></figure></p><p>把0强制类型转化为void (*) () 型的函数指针。也就是指向函数地址为0的指针 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">void</span> (*) () ) <span class="number">0</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;当我们看到如下所示的代码怎么去理解它的意义呢。&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p
      
    
    </summary>
    
      <category term="c语言" scheme="http://begild.top/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="指针" scheme="http://begild.top/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>测试编译器是否支持嵌套注释</title>
    <link href="http://begild.top/2017/10/01/%E6%B5%8B%E8%AF%95%E7%BC%96%E8%AF%91%E5%99%A8%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%B5%8C%E5%A5%97%E6%B3%A8%E9%87%8A/"/>
    <id>http://begild.top/2017/10/01/测试编译器是否支持嵌套注释/</id>
    <published>2017-09-30T16:16:47.000Z</published>
    <updated>2018-03-01T03:30:28.710Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>问题：某些C编译器允许嵌套注释。请写一个测试程序，要求：无论是对允许嵌套注释的编译器，还是对不允许嵌套注释的编译器，该程序都能正常通过编译（无错误消息出现）， 但是这两种情况下程序执行的结果却不相同。</p><p>提示： 在用双引号括起的字符串中， 注释符 /* 属于字符串的一部分，而在注释中出现的双引号 “ “ 又属于注释的一部分。</p><p>出自——《C陷阱与缺陷》练习1-1</p><a id="more"></a><p>嵌套注释：顾名思义就是注释里嵌套着注释。比如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*"/*"*/</span><span class="string">"*/</span></span><br></pre></td></tr></table></figure></p><p>对于这段代码，不同的编译器识别的结果不同：</p><p><img src="https://s1.ax1x.com/2017/10/01/13Ezn.png" alt=""></p><p>我们如何通过代码的输出判定编译器是否支持嵌套注释呢，重点就是让同一段代码，支持嵌套注释的编译器和不支持嵌套注释的编译器注释掉不同的地方。根据题目的提示字符串中的 /* 是属于字符串的一部分，比如 “/*aa*/“ 这里面的注释标号编译器是不会理会的，而 /*“aa*“/ 这里面的 “aa” 是不会识别为字符串的。还有一点无论是 “ “ 还是 /**/都是就近匹配的。</p><ul><li><ol><li>我们首先构建一个嵌套的注释，这个注释在<strong>支持</strong>嵌套注释的编译器里能编译通过，而在<strong>不支持</strong>的编译器里编译失败：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*"/*"*/</span><span class="string">"*/</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><p>不支持的系统中出现了”*/“导致编译失败</p><p><img src="https://s1.ax1x.com/2017/10/01/13Ezn.png" alt=""></p><ul><li><ol><li>我们通过添加一个 “ 使得不支持的系统编译成功<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*"/*"*/</span><span class="string">"*/"</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><p><img src="https://s1.ax1x.com/2017/10/01/13KdU.png" alt=""></p><ul><li><ol><li>可以看出这样添加之后不支持的编译器已经能编译成功并且有输出一字符串，支持的系统由于多了一个 “ 导致编译失败，根据题目提示我们构建一个字符串”  “并且”/*,*/“ 两两配对，所以我们添加一个 /*形成”/*“ <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*"/*"*/</span><span class="string">"*/"</span><span class="comment">/*"</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><p><img src="https://s1.ax1x.com/2017/10/01/13MoF.png" alt=""></p><ul><li><ol><li>这样操作之后支持/不支持的编译器输出不同的字符串(蓝色部分),但是不支持的编译器多了 /* “编译失败，而它刚好又是多行注释的头,所以我们得加一个尾 */ 使得他们配对。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*"/*"*/</span><span class="string">"*/"</span><span class="comment">/*"*/</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><p><img src="https://s1.ax1x.com/2017/10/01/13li4.png" alt=""></p><ul><li><ol><li>我们从上图可以看出不支持嵌套注释的编译器已经能通过编译并且有区别去支持嵌套注释的编译器的输出。但是支持嵌套注释的编译器由于多了*/导致编译失败，因为不支持嵌套注释的编译器的注释之间无论是什么都可以忽略，所以我们在最后的   */ 之前加一个 /* 让支持嵌套注释的编译器能找到配对的注释对。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*"/*"*/</span><span class="string">"*/"</span><span class="comment">/*"/**/</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><p><img src="https://s1.ax1x.com/2017/10/01/131JJ.png" alt=""></p><p>通过上述步骤我们找到了一个合适的语句使得在两种编译器中编译成功并且有不同的输出。</p><p><img src="https://s1.ax1x.com/2017/10/01/133W9.png" alt=""></p><p>通过一段简单的代码我们可以看下效果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ISSupNestComment</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This compiler %s support nested comment \r\n"</span>,</span><br><span class="line">           ISSupNestComment()? <span class="string">""</span>: <span class="string">"does not"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ISSupNestComment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *Str=<span class="comment">/*"/*"*/</span><span class="string">"*/"</span><span class="comment">/*"/**/</span>;</span><br><span class="line">    <span class="keyword">if</span>(Str[<span class="number">0</span>]==<span class="string">'*'</span>)<span class="comment">//"*/"不支持嵌套注释</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>           <span class="comment">//"/*"支持嵌套注释</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己做完这个感觉还是有点意思的，上网搜了一波，发现别人想的更是精妙。不禁发出一套赞赏三连，卧槽牛逼666。下面我们看下一大佬们是怎么做的。</p><h1 id="1-Doug-McIlroy"><a href="#1-Doug-McIlroy" class="headerlink" title="1.Doug McIlroy"></a>1.Doug McIlroy</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*/*/</span><span class="number">0</span>*<span class="comment">/**/</span><span class="number">1</span></span><br></pre></td></tr></table></figure><p> 这个解法主要利用了编译器作词法分析时的“大嘴法”规则。编译器支持嵌套注释，则上式将被解释为<strong>1</strong>.编译器不支持嵌套注释，则上式将被解释为 <strong>0*1</strong>.</p><p><img src="https://s1.ax1x.com/2017/10/01/135Wj.png" alt=""></p><h1 id="2-TimWu"><a href="#2-TimWu" class="headerlink" title="2.TimWu"></a>2.<a href="http://www.cppblog.com/Tim/archive/2011/03/25/142726.html" target="_blank" rel="noopener">TimWu</a></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A <span class="comment">/* aaa /* a*/</span> a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CanNesting</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> B</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他利用的多行注释和宏定义的特性，编译器支持嵌套注释宏定义B则会被注释掉导致没有宏定义B。编译器不支持嵌套注释，宏定义B则会定义为 */。通过预编译判断就可以输出结果。</p><p><img src="https://s1.ax1x.com/2017/10/01/13OTU.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;问题：某些C编译器允许嵌套注释。请写一个测试程序，要求：无论是对允许嵌套注释的编译器，还是对不允许嵌套注释的编译器，该程序都能正常通过编译（无错误消息出现）， 但是这两种情况下程序执行的结果却不相同。&lt;/p&gt;
&lt;p&gt;提示： 在用双引号括起的字符串中， 注释符 /* 属于字符串的一部分，而在注释中出现的双引号 “ “ 又属于注释的一部分。&lt;/p&gt;
&lt;p&gt;出自——《C陷阱与缺陷》练习1-1&lt;/p&gt;
    
    </summary>
    
      <category term="c语言" scheme="http://begild.top/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="嵌套注释" scheme="http://begild.top/tags/%E5%B5%8C%E5%A5%97%E6%B3%A8%E9%87%8A/"/>
    
  </entry>
  
  <entry>
    <title>处理器大小端存储模式</title>
    <link href="http://begild.top/2017/09/13/%E5%A4%A7%E5%B0%8F%E7%AB%AF/"/>
    <id>http://begild.top/2017/09/13/大小端/</id>
    <published>2017-09-13T09:01:49.000Z</published>
    <updated>2018-03-01T03:30:40.863Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>大端模式：是指数据的<strong>高字节</strong>保存在内存的<strong>低地址</strong>中，而数据的<strong>低字节</strong>保存在内存的<strong>高地址</strong>中。</p><p>小端模式：是指数据的<strong>高字节</strong>保存在内存的<strong>高地址</strong>中，而数据的<strong>低字节</strong>保存在内存的<strong>低地址</strong>中。</p><p>例如：一个数据无符号32位整数0x12345678,其中0x12属于高字节(权值大)而0x78属于低字节(权值小),在不同的模式下存储的方式如下表：</p><table><thead><tr><th>内存地址</th><th>0x1000</th><th>0x1001</th><th>0x1002</th><th>0x1003</th></tr></thead><tbody><tr><td>大端模式</td><td>0x12</td><td>0x34</td><td>0x56</td><td>0x78</td><td></td></tr><tr><td>小端模式</td><td>0x78</td><td>0x56</td><td>0x34</td><td>0x12</td><td></td></tr></tbody></table><p>我们可以看得出来大端模式和我们的阅读习惯相同，权值从左往右是高位-&gt;低位而地址则是低位-&gt;高位。小端模式则是随着地址从左往右增大权值增大。地址就代表了权值的大小。</p><a id="more"></a><p>利用下面c代码可以看到运行环境是如何存储一个uint数据的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">endian</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> arg[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> a=<span class="number">0x12345678</span>;</span><br><span class="line">    <span class="keyword">char</span> *ap=&amp;a;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0x%x storage in system is:\r\n"</span>,a);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"addr:0x%x,value:0x%x\r\n"</span>,ap+i,ap[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"system storage by %s_endian"</span>,endian()? <span class="string">"Big"</span>:<span class="string">"Little"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行的结果如下，可以看出该系统是小端系统。</p><p><a href="https://imgchr.com/i/1Mp4A" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2017/10/01/1Md81.png" alt=""></a></p><p>我们如何简单的判断一个系统的大小端呢。我们知道<strong>共用体(联合体)</strong>存储在内存里是共用一块地址的，其占用空间决定于最大成员所需的空间,他们的起始地址相同。所以我们可以利用一个共用体,成员分别是一个int和一个char。通过给int赋值1，然后检测char对应的值是多少，如果是1代表系统将数据1放到了int的起始地址(因为char是一个字节必然在起始地址)。而起始地址是低地址，低地址存放的1(权值小)推出该系统是小端系统。否则该系统是大端系统。</p><p>C代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">endian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">    &#125;endunion;</span><br><span class="line">    endunion.a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(endunion.b==<span class="number">1</span>)<span class="comment">//如果成员b是1则证明随地址顺序和数字权值顺序相同是小端模式</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//小端</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//大端</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还可以用一个更加简洁的办法(原理都是检测int的起始地址存放的是什么值)，代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">endian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> !(*((<span class="keyword">char</span> *)&amp;a));<span class="comment">//取a的地址，将其强制转化为char指针，然后取出该地址存放的值并取反;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大端模式：是指数据的&lt;strong&gt;高字节&lt;/strong&gt;保存在内存的&lt;strong&gt;低地址&lt;/strong&gt;中，而数据的&lt;strong&gt;低字节&lt;/strong&gt;保存在内存的&lt;strong&gt;高地址&lt;/strong&gt;中。&lt;/p&gt;
&lt;p&gt;小端模式：是指数据的&lt;strong&gt;高字节&lt;/strong&gt;保存在内存的&lt;strong&gt;高地址&lt;/strong&gt;中，而数据的&lt;strong&gt;低字节&lt;/strong&gt;保存在内存的&lt;strong&gt;低地址&lt;/strong&gt;中。&lt;/p&gt;
&lt;p&gt;例如：一个数据无符号32位整数0x12345678,其中0x12属于高字节(权值大)而0x78属于低字节(权值小),在不同的模式下存储的方式如下表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;内存地址&lt;/th&gt;
&lt;th&gt;0x1000&lt;/th&gt;
&lt;th&gt;0x1001&lt;/th&gt;
&lt;th&gt;0x1002&lt;/th&gt;
&lt;th&gt;0x1003&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;大端模式&lt;/td&gt;
&lt;td&gt;0x12&lt;/td&gt;
&lt;td&gt;0x34&lt;/td&gt;
&lt;td&gt;0x56&lt;/td&gt;
&lt;td&gt;0x78&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;小端模式&lt;/td&gt;
&lt;td&gt;0x78&lt;/td&gt;
&lt;td&gt;0x56&lt;/td&gt;
&lt;td&gt;0x34&lt;/td&gt;
&lt;td&gt;0x12&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;我们可以看得出来大端模式和我们的阅读习惯相同，权值从左往右是高位-&amp;gt;低位而地址则是低位-&amp;gt;高位。小端模式则是随着地址从左往右增大权值增大。地址就代表了权值的大小。&lt;/p&gt;
    
    </summary>
    
      <category term="c语言" scheme="http://begild.top/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="大小端存储" scheme="http://begild.top/tags/%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
</feed>
