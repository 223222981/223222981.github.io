<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[STM32 Flash的读写]]></title>
    <url>%2F2018%2F03%2F07%2FSTM32-Flash-Write-Read%2F</url>
    <content type="text"><![CDATA[这里记一下STM32F4板子FLASH的读写操作以及需要注意的地方。 FLASH的写操作 FLASH由 ‘1’ 变为 ‘0’ 不能由 ‘0’ 变为 ‘1’ ，所以在写入之间需要检测是否为 ‘1’ ,并且擦除flash只能按照一个扇区来删除，由上可知，我们写入之前必须确保我们需要写入的地址读回来的值是0XFF，如果不是0XFF就需要将整个扇区擦除(扇区变为全 ‘1’ )。 写入操作(包括擦除)之前需要将FLASH解锁 FLASH_Unlock()，操作完成之后需要将FLASH上锁 FLASH_Lock() 。 正点原子的例子 写入流程: 解锁FLASH FLASH_Unlock()； 禁止数据缓存FLASH_DataCacheCmd(DISABLE),根据你传入的起始地址 WriteAddr 和写入的字节数 NumToWrite 计算出结束地址 endaddr； 遍历整个写入范围，一旦发现非 ’1‘ 数据的出现就擦除整个扇区，他这里是字(Word)来检测的，所以地址 addrx 每次加4； 检测完毕并且擦除之后，进入写操作，每次写入一个字(4byte)的数据。所以 WriteAddr 每次加4, u32 *pBuffer 每次加1 ； 使能数据缓存FLASH_DataCacheCmd(ENABLE)，上锁FLASH FLASH_Lock()。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//从指定地址开始写入指定长度的数据//特别注意:因为STM32F4的扇区实在太大,没办法本地保存扇区数据,所以本函数// 写地址如果非0XFF,那么会先擦除整个扇区且不保存扇区数据.所以// 写非0XFF的地址,将导致整个扇区数据丢失.建议写之前确保扇区里// 没有重要数据,最好是整个扇区先擦除了,然后慢慢往后写.//该函数对OTP区域也有效!可以用来写OTP区!//OTP区域地址范围:0X1FFF7800~0X1FFF7A0F//WriteAddr:起始地址(此地址必须为4的倍数!!)//pBuffer:数据指针//NumToWrite:字(32位)数(就是要写入的32位数据的个数.)void STMFLASH_Write(u32 WriteAddr, u32 *pBuffer, u32 NumToWrite)&#123; FLASH_Status status = FLASH_COMPLETE; u32 addrx = 0; u32 endaddr = 0; if(WriteAddr &lt; STM32_FLASH_BASE || WriteAddr % 4)return; //非法地址 FLASH_Unlock(); //解锁 FLASH_DataCacheCmd(DISABLE);//FLASH擦除期间,必须禁止数据缓存 addrx = WriteAddr; //写入的起始地址 endaddr = WriteAddr + NumToWrite * 4; //写入的结束地址 if(addrx &lt; 0X1FFF0000) //只有主存储区,才需要执行擦除操作!! &#123; while(addrx &lt; endaddr) //扫清一切障碍.(对非FFFFFFFF的地方,先擦除) &#123; if(STMFLASH_ReadWord(addrx) != 0XFFFFFFFF) //有非0XFFFFFFFF的地方,要擦除这个扇区 &#123; status = FLASH_EraseSector(STMFLASH_GetFlashSector(addrx), VoltageRange_3); //VCC=2.7~3.6V之间!! if(status != FLASH_COMPLETE)break; //发生错误了 &#125; else addrx += 4; &#125; &#125; if(status == FLASH_COMPLETE) &#123; while(WriteAddr &lt; endaddr) //写数据 &#123; if(FLASH_ProgramWord(WriteAddr, *pBuffer) != FLASH_COMPLETE) //写入数据 &#123; break; //写入异常 &#125; WriteAddr += 4; pBuffer++; &#125; &#125; FLASH_DataCacheCmd(ENABLE); //FLASH擦除结束,开启数据缓存 FLASH_Lock();//上锁&#125; 测试和分析经过实验，擦除扇区的时间是很久的，擦除128KByte的扇区大概需要1s多。并且，不解锁虽然可以通过擦除函数并且返回 FLASH_COMPLETE 但是实际并没有擦除成功。我开始以为他这个耗时主要体现在读和判断，擦除操作比较快，😒但其实读120KByte的数据只需要3.9ms加上判断的时间也没多少主要的时间耗费在擦除操作上。😆另一个体现就是如果在 Keil 的工程选项里把擦除全部flash勾选，下载前的擦除的时间是很长的。下面是测试代码和解释结果。测试结果可以看出，擦除的时间并没有很大变化，因为都是需要一次性操作一个扇区，只要不超过一个扇区的长度都不会变化很大。写入和读出的时间保持线性变化。所有的测试都是用原子官方例程按照WORD(32bit)来写入的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int main(void)&#123;...上续代码 STMFLASH_Write(FLASH_SAVE_ADDR, (u32 *)&amp;txbuf, SIZE);//写入一些数据保证flash不全为'1' uprintf(USART1, "扇区预先不为全 '1'时写入:\r\n"); uprintf(USART1, "写入长度:%d\r\n", TEXT_LENTH); //原子的例子擦除flash再写入数据 STMFLASH_Write(FLASH_SAVE_ADDR, (u32 *)&amp;txbuf, SIZE); memset(readbuf,0,TEXT_LENTH);//清空数据读取 StartTiming(); STMFLASH_Read(FLASH_SAVE_ADDR, (u32 *)&amp;readbuf, SIZE); timems = GetTimeMs(); uprintf(USART1, "读出耗时:%.3fms\r\n", timems); uprintf(USART1, "读出长度:%d\r\n----\r\n", TEXT_LENTH, strlen((const char *)readbuf));...下续代码&#125;void STMFLASH_Write(u32 WriteAddr, u32 *pBuffer, u32 NumToWrite)&#123;...上续代码 FLASH_DataCacheCmd(DISABLE);//FLASH擦除期间,必须禁止数据缓存 StartTiming();//开始计时擦除扇区耗时.....上续代码 timems = GetTimeMs(); uprintf(USART1,"擦除扇区耗时 :%.3fms\r\n",timems); StartTiming();//开始写入计时 if(status == FLASH_COMPLETE) &#123;...上续代码 FLASH_Lock();//上锁 timems = GetTimeMs();//获取写入耗时 uprintf(USART1, "写入耗时:%.3fms\r\n", timems);&#125;/*测试结果 测试120、12K、120K(Byte)的数据*/扇区预先不为全 '1'时写入:写入长度:120擦除扇区耗时 :1046.720ms写入耗时:0.440ms读出耗时:0.020ms读出长度:120 ----扇区预先不为全 '1'时写入:写入长度:12288擦除扇区耗时 :1050.220ms写入耗时:45.700ms读出耗时:0.380ms读出长度:12288 ----扇区预先不为全 '1'时写入:写入长度:122880擦除扇区耗时 :1051.860ms写入耗时:458.700ms读出耗时:3.880ms读出长度:122880 ---- 改进擦除方式 改进的一点想法根据正点原子的测试结果来看，擦除扇区的时间是不可避免的，无非就是暴力一点不检测直接擦除(因为通常来说，如果你存储在固定的flash地址除了第一次之后都会有数据)。这样搞了之后从测试的结果来看提升并不明显。写120KByte的数据下擦除时间少了4ms左右😔(少了读取和判断的时间)。所以擦除的方式并没有很好的改进方法(标题党😈)。 通用性考虑 通过正点原子的例子熟悉了Flash的读写，但是只支持4字节对齐(WORD)的操作,我看了一下库的函数是可以支持 BYTE，HALFWORD,WORD, 和 DOUBLEWORD 的，不过 DOUBLEWORD 需要外部Vpp。所以想改进一些支持库函数里的各种byte(1-4) 的操作。 修改好之后测试一下测试代码和上面原版的差不多。只是写入函数换成了修改之后的STMFLASH_WriteWithErase，测试结果如下,测试的时候用的是WORD方式写入。和原子基本没有差别。123456789101112131415161718192021扇区预先不为全 '1'时写入:写入长度:120擦除扇区耗时 :1043.500ms写入耗时:0.460ms读出耗时:0.000ms读出长度:120 ----扇区预先不为全 '1'时写入:写入长度:12288擦除扇区耗时 :1046.580ms写入耗时:45.700ms读出耗时:0.400ms读出长度:12288 ----扇区预先不为全 '1'时写入:写入长度:122880擦除扇区耗时 :1050.860ms写入耗时:459.140ms读出耗时:3.900ms读出长度:122880 ---- 其他ByteSize方式写入相对于用WORD来说用其他方式写入flash是要慢一些的。采用 BYTE 方式需要 大概1832ms,采用HALFWORD方式需要920ms左右。因为擦除都是采用的VoltageRange_3也就是WORD方式所以擦除时间差不多。 分离操作的方式 分离操作的意义把擦除和写入分开。考虑到一个扇区是非常大的，一个扇区可能会存储多种数据。如果写入之前有数据就会导致整个扇区被擦除，数据就会丢失。所以采用分离的办法，把数据的写入和擦除分隔开，根据需要选择是否擦除扇区内的数据，保证在擦除的操作之前有相应的备份操作就OK了。这样即使忘记擦除那么也只是新的数据没法正确写到flash里面，其他部分的数据就不会被擦除，这样有利于更好的数据完整性。 测试结果和测试代码,经过测试分离之后的操作和没分离的时间上基本没什么差别，12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849分离操作方式写入flash:擦除扇区耗时:1023.320ms写入长度:120 byte写入耗时:0.440ms读出耗时:0.000ms读出长度:120 byte****分离操作方式写入flash:擦除扇区耗时:1015.140ms写入长度:12288 byte写入耗时:45.940ms读出耗时:0.400ms读出长度:12288 byte****合并操作方式写入flash:写入长度:122880擦除扇区耗时 :1010.480ms写入耗时:461.420ms读出耗时:3.900ms读出长度:122880 ****int main（void）&#123;...上续代码 uprintf(USART1, "分离操作方式写入flash:\r\n"); StartTiming(); status = StmEraseFlashSector(FLASH_SAVE_ADDR, TEXT_LENTH); //FLASH_DataCacheCmd(DISABLE);//FLASH擦除期间,必须禁止数据缓存 //status = FLASH_EraseSector(STMFLASH_GetFlashSector(FLASH_SAVE_ADDR), VoltageRange_3); //VCC=2.7~3.6V之间!! if(status != FLASH_COMPLETE) &#123; uprintf(USART1, "擦除扇区失败:%d\r\n",status); //发生错误了 while(1) &#123;&#125;; &#125; timems = GetTimeMs(); uprintf(USART1, "擦除扇区耗时:%.3fms\r\n", timems); uprintf(USART1, "写入长度:%d byte\r\n", TEXT_LENTH); StartTiming(); //不需要擦除falsh直接写数据 STMFLASH_WriteNoErase(FLASH_SAVE_ADDR, txbuf,TEXT_LENTH,ByteSize); timems = GetTimeMs(); uprintf(USART1, "写入耗时:%.3fms\r\n", timems); memset(readbuf,0,TEXT_LENTH);//清空数据读取 StartTiming(); STMFLASH_Read(FLASH_SAVE_ADDR,readbuf, TEXT_LENTH,ByteSize); timems = GetTimeMs(); uprintf(USART1, "读出耗时:%.3fms\r\n", timems); uprintf(USART1, "读出长度:%d byte\r\n****\r\n", TEXT_LENTH, strlen((const char *)readbuf)); &#125; 后记搞了几天才把这个写完整。中途也进了好多的坑，浪费了好长时间。不过还是写完了。说一点注意的地方 flash的写入地址不是偶数就可以，得是4的倍数。 无论是擦除还是写入都需要先解锁flash。读取则不需要。 对于同一个扇区的建议用分离的操作，并且在操作前根据需要把其他的数据读出来备份一下在写进去。 关于本文的代码详见于Coding项目。]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>Flash读写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32自定义串口printf]]></title>
    <url>%2F2018%2F03%2F01%2FSTM32-UART-CustomPrintf%2F</url>
    <content type="text"><![CDATA[前言硬件的调试通常可分为两大类，一种是用调试器将芯片和电脑连接通过单步等方式逐步运行进行调试，另一种就是printf大法在程序运行过程中输出调试信息。第一种比较深入，可以了解每一个变量，栈堆，函数等等的变化是比较系统化的调试。但我通常都是用printf来调试的，因为快速简单属于非介入的方式，调试完毕直接注释掉相关部分就行了。 重定向 printf 函数对于STM32来说现在串口例程一般都配有一个printf重定向到串口1的代码，直接可以使用printf很方便的输出信息到串口上。1234567//重定义fputc函数int fputc(int ch, FILE *f)&#123; while((USART1-&gt;SR&amp;0X40)==0);//循环发送,直到发送完毕 USART1-&gt;DR = (u8) ch; return ch;&#125; 自定义printf函数但是我们如果使用多个串口或者说串口输出不一定总从串口1输出怎么办呢。这时候这样就没法实现，后来上网查一下我们可以自己实现printf这个函数。命名为uprintf，接收至少两个参数，第1个参数是串口号;第2个是格式化字符串;第3-n ‘ … ‘ 是参数匹配列表， 实现变长的参数列表接收。。1234567891011//用串口写一个printf函数void uprintf(USART_TypeDef *USARTx, const char *fmt, ...)&#123; va_list ap; //typedef char *va_list; va_list是char型的指针 char *s_string = malloc(300); //申请缓冲区 va_start(ap, fmt); //找第一个可变形参的地址，并把地址赋给ap vsprintf(s_string, fmt, ap); //类似sprintf函数 USART_String(USARTx, s_string); //发送和整个字符串 va_end(ap); //结束 free(s_string);&#125; 上面这个函数里的过程: 通过 va_start 函数获得参数列表里每个项和格式化字符里对应的位置，形成一个列表 ap 。 通过 vsprintf 把列表里每个参数转为字符串写到 s_string 字符串里。 通过 USART_String 发送到串口。 释放列表 ap 和 发送缓冲 s_string 。 完整的一个自定义printf实现文件1234567891011121314151617181920212223242526272829#include "uart_x.h"#include "stdlib.h"#include "stdarg.h"//发送一个字节void SendByte(USART_TypeDef *USARTx, unsigned char dat)&#123; while((USARTx-&gt;SR &amp; 0X40) == 0) &#123;&#125;; //循环发送,直到发送完毕 USARTx-&gt;DR = (u8) dat;&#125;//发送一个字符串void USART_String(USART_TypeDef *USARTx, char *s)&#123; while(*s != '\0') // '\0' 表示字符串结束标志 &#123; SendByte(USARTx, *s); s++; &#125;&#125;//用串口写一个printf函数void uprintf(USART_TypeDef *USARTx, const char *fmt, ...)&#123; va_list ap; //typedef char *va_list; va_list是char型的指针 char *s_string = malloc(300); //申请空间 va_start(ap, fmt); /找第一个可变形参的地址，并把地址赋给ap vsprintf(s_string, fmt, ap); //类似sprintf函数 USART_String(USARTx, s_string); //发送和整个字符串 va_end(ap); //结束 free(s_string);&#125; 上面的函数已经能满足多个串口同时使用printf，根据自己的需求可以修改申请的缓冲区大小即可。 安全版本的自定义 printf 实现但上面的实现并不是安全的，如果你发送的字符串长度大于缓冲区长度就会造成内存溢出。所以你可以更改为一个安全的版本，接收一个缓冲区长度参数从而申请一个合适大小的空间。1234567891011//用串口写一个printf函数void uprintf_s(USART_TypeDef *USARTx, uint32_t BuffSize,const char *fmt, ...)&#123; va_list ap; //typedef char *va_list; va_list是char型的指针 char *s_string = malloc(BuffSize); //申请空间 va_start(ap, fmt); //找第一个可变形参的地址，并把地址赋给ap vsprintf_s(s_string,BuffSize, fmt, ap); //类似sprintf_s函数 USART_String(USARTx, s_string); //发送和整个字符串 va_end(ap); //结束 free(s_string);&#125; 后记 使用 printf 大法非常方便，但是尽量避免在中断里调用该函数(执行 printf 需要的时间比较久),以及调试完毕之后注释掉相关的代码，缩短功能代码的执行时间。 有兴趣的可以写 printf 到 OLED 之类的函数，原理都是一样，实现屏幕位置控制和最后的写一个字节的函数就能完成移植。]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>串口(UART)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SMT32串口接收、空闲中断]]></title>
    <url>%2F2018%2F03%2F01%2FSTM32-UART-IDLE-IT-md%2F</url>
    <content type="text"><![CDATA[识别尾进行接收结束的验证 串口接收完毕标志可以利用识别特定字符(字符串)来检测，比如 “\r\n”、’*#’ 之类的。所以每次发数据都需要加上这些字符才能被识别为接收完毕，这样好处就是比较通用。无论是什么硬件平台都能用。代码也不复杂，在STM32平台上简单的例子如下代码段：当接收到 ‘*‘ 时候就会置位接收完成标志位，就可以进行处理了。123456789101112131415161718#define MAXUSART1BUFSIZE 200uint8_t Uart1_BUF[MAXUSART1BUFSIZE];void USART1_IRQHandler(void) //串口1中断服务程序 &#123; uint8_t RecByte; static uint32_t pos = 0; if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) &#123; RecByte = USART1-&gt;DR;//读取接收到的数据 if(pos &lt; MAXUSART1BUFSIZE)//防止内存溢出 Uart1_BUF[pos++] = RecByte; if(RecByte == '*') &#123; //TODO: 接收完毕相关处理 pos = 0; &#125; &#125;&#125; 识别头尾进行数据段的保护 上面的方法就是发送的时候麻烦一点，每次都需要在后面加 ‘*‘, 并且如果发送错一次(忘记加 ‘*’)就会把缓冲区的内容累计到下一次(可以添加头识别进行解决)。这样就只会识别指定的数据段。一般这样适用于发送带有意义的控制数据保证数据不多收也不少收。验证的字符要保证不会出现在内容里，或者用多个字符进行验证。12345678910111213141516171819202122232425#define MAXUSART1BUFSIZE 200uint8_t Uart1_BUF[MAXUSART1BUFSIZE];void USART1_IRQHandler(void) //串口1中断服务程序&#123; uint8_t RecByte; static uint32_t pos = 0; if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) //接收中断(接收到的数据必须是0x0d 0x0a结尾) &#123; RecByte = USART1-&gt;DR;//读取接收到的数据 if(RecByte == '#') pos = 1; //开始接收数据 if(pos) &#123; if(pos &lt; MAXUSART1BUFSIZE)//防止内存溢出 Uart1_BUF[pos - 1] = RecByte; pos ++; if(RecByte == '*') &#123; //TODO: 接收完毕相关处理 pos = 0; &#125; &#125; &#125;&#125; STM32空闲中断的配置 前几天做项目也要用到串口传输控制信息在STM32上的话可以利用串口空闲中断(接收完字符以后在下一个传输字符的时间内没有字符传来)来接收数据，这样就不用像上面那样做特定的识别，也比较方便。在这里备注一下，因为当时一开始配置完了并不起作用，后来上网查证了最后才找到解决办法。初始化的代码就不贴了，主要是最后配置完毕，开中断的代码贴一下。 123456...上续初始化的相关配置USART_Init(USART1, &amp;USART_InitStructure); //初始化串口USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启中断USART_ITConfig(USART1, USART_IT_IDLE,ENABLE);//开启中断//USART_ClearITPendingBit(USART1, USART_IT_IDLE |USART_IT_RXNE);//清除中断USART_Cmd(USART1, ENABLE); //使能串口 一开始我使用的是下面这条语句进行中断配置的，发现并不能触发空闲中断，后来才知道必须要分两次才能正确配置: 1USART_ITConfig(USART1, USART_IT_RXNE | USART_IT_IDLE, ENABLE);//开启中断 查看了一下USART_ITConfig()函数的源码才看出来，他这个函数为了USART_IT_IDLE等中断宏定义的通用性，必须每次只能初始化一个中断标志。 12345678910111213141516void USART_ITConfig(USART_TypeDef *USARTx, uint16_t USART_IT, FunctionalState NewState)&#123;.... /* Get the interrupt position */ itpos = USART_IT &amp; IT_Mask; itmask = (((uint32_t)0x01) &lt;&lt; itpos);....&#125;/*相关计算#define USART_IT_IDLE ((uint16_t)0x0424)#define IT_Mask ((uint16_t)0x001F) //!&lt; USART Interrupt Mask itpos = 0x0424 &amp; 0x001F = 0x04;itmask = (((uint32_t)0x01) &lt;&lt; itpos) = 0x10;0x10 = 0b00010000//bit[4];查阅官方的手册可以看到空闲中断使能也恰好就是bit[4];*/ 究其原因是因为itmask这个变量其实就是中断位于寄存器的位置，他是一个0bxx1xx的变量。只能表示一个中断标志位所以每次只能初始化一个标志位。 STM32空闲中断服务函数 接下来就是中断服务函数了： 123456789101112131415161718192021uint8_t USART1RecBuf[USART1RecBufMaxSize];//接收缓冲区uint8_t sdfsdf = 0;void USART1_IRQHandler(void) //串口1中断服务程序&#123; static uint16_t pos = 0; if(USART_GetITStatus(USART1, USART_IT_IDLE) != RESET) //接收完毕触发空闲中断 &#123; pos = 0; USART1-&gt;DR;//清除空闲中断标志位 //TODO: 中断接收完成标志 &#125; if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) &#123; uint8_t RecByte; Res = USART1-&gt;DR; //读取接收到的数据 if(pos &gt;= USART1RecBufMaxSize) //超过范围返回 return ; USART1RecBuf[pos++] = RecByte; &#125;&#125; 这里需要注意的就是空闲中断的清除并不是调用USART_ClearITPendingBit()函数来清除,查看库的函数源码实现也可以看到注释里并没有说明 USART_IT_IDLE 该参数是可以被传入的，并且我们使用 USART1-&gt;DR 就能清除串口空闲中断。 12345678910111213/**... * @param USART_IT: specifies the interrupt pending bit to clear. * This parameter can be one of the following values: * @arg USART_IT_CTS: CTS change interrupt (not available for UART4 and UART5) * @arg USART_IT_LBD: LIN Break detection interrupt * @arg USART_IT_TC: Transmission complete interrupt. * @arg USART_IT_RXNE: Receive Data register not empty interrupt.... */void USART_ClearITPendingBit(USART_TypeDef *USARTx, uint16_t USART_IT)&#123;···· 到此完成了串口空闲中断的配置，之后只要两次接收数据之间的时间大于一个字符的时间(跟波特率有关),就能触发这个中断。]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>串口(UART)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ESP8266工程的裁剪和编译]]></title>
    <url>%2F2018%2F01%2F23%2FESP8266%E5%B7%A5%E7%A8%8B%E7%9A%84%E8%A3%81%E5%89%AA%E5%92%8C%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[前言本篇文章主要讲一下，乐鑫官方给的ESP8266 Demo怎么裁剪成我们要的样子以及编译。 模板工程所需文件由于官方给的工程是包含了全部的Demo和库所以我们直接使用是不能编译的。我们就从一个最基础的工程模板开始裁剪，因为其他的功能都可以通过工程模板添加库和代码来实现。首先亮一下官方原版的RTOS SDK的工程结构(下左图)。 我们需要把这个工程做成一个最基本的模板那么就需要把里面冲突的和暂时不需的都给删除。如下图是需要裁剪的内容： 红色的是需要删除的。紫色的删了节省空间。所以我们把刚刚标记这些都全部删除(别忘了备份一个原版的以后用)之后，这样就会少了很多东西。那现在可以编译了吗？打扰了，并不行。因为makefile这个神奇的东西存在，所以我们需要做一些调整和更改使得makefile能正确的识别、编译、链接整个工程。至于makefile是什么东西大家上网搜查看！这里就不展开讲了，因为就那个就可以做一个专题23333。你暂时只需要知道编译整个工程需要它掌控整个工程的各个文件的信息和关系的，所以我们需要告诉它各个文件的信息和之间的关系，所幸的是官方给的makefile已经很通用了，我们稍微做改变就可以了(感谢ing…) 模板工程文件的调整下面的操作就是属于比较灵性的，不要问我为什么因为我个人觉得这样比较好。先按照我的来，等你学会了就可以去装逼了。先约定”/“就是工程的根目录，用绝对路径目录有点长。 剪切 /driver_lib/driver —&gt; /examples/project_template/ 剪切 /driver_lib/include/ 的所有头文件 —&gt; /examples/project_template/include/ 改名 /examples/project_template —&gt; app 复制 /examples/app —&gt; / 删除 /app/sample_lib 目录 删除 /driver_lib 目录 删除 /examples 目录 这样就完成了工程文件的调整：把相关的硬件驱动移到app目录下面，并且删除了示例的库。调整完成之后的目录如下图(documents目录删不删不影响)： MakeFile文件的修改 修改/Makefile文件 文件里添加两句话SDK_PATH=××× BIN_PATH=xxx 比如我的工程根目录在 “ e:/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template “那么我的文件修改如下：12345678910....ifndef PDIRendifSDK_PATH=e:/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_templateBIN_PATH=e:/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/bin ifeq ($(COMPILE), xcc)... 2.修改/app/Makefile文件 文件里添加一句话SDK_PATH=××× 添加在文件的17行左右，内容就是你工程的根目录。 文件里的SUBDIR=××× 把所有包含了c文件的子目录都添加进去。(‘\’表示续一行)，ctrl+f可快速查找，修改位置大概在23行左右。 修改完成之后如下： 123456789101112131415...上续#FLAVOR = releaseFLAVOR = debugSDK_PATH=e:/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template#EXTRA_CCFLAGS += -uifndef PDIR # &#123;GEN_IMAGES= eagle.app.v6.outGEN_BINS= eagle.app.v6.binSPECIAL_MKTARGETS=$(APP_MKTARGETS)SUBDIRS= \ user \ driverendif # &#125; PDIR...下续 把COMPONENTS_eagle.app.v6=××× 需要的.a文件修改为子目录下生成对应的.a文件(听不懂没关系，看效果代码)，大概在48行左右。 123456789101112...上续ifeq ($(FLAVOR),release)TARGET_LDFLAGS += -g -O0endifCOMPONENTS_eagle.app.v6 = \ user/libuser.a \ driver/libdriver.a LINKFLAGS_eagle.app.v6 = \ -L$(SDK_PATH)/lib \ -Wl,--gc-sections \...下续 这样就修改完成了。 工程的编译 左键点击工程名选中工程-&gt;右键弹出菜单-&gt;BuildProject 即可编译。如果出现BuildProject选项灰色就是你没选中。如果失败可以尝试CleanProject(就在BuildProject下面)一下工程再编译。 编译之后输出窗口大致如下，输出两个bin文件：eagle.flash.bin 和 eagle.irom0text.bin ,这样就完成了工程的编译。这个固件是不支持OTA升级的，所以也不需要boot。也没有user1.bin和user2.bin。所以不要觉得奇怪。123456789101112131415161718192023:48:32 **** Incremental Build of configuration Default for project ESP8266_RTOS_SDK-1.5-project_template ****make all make[1]: Entering directory &apos;/cygdrive/e/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/app&apos;make[2]: Entering directory &apos;/cygdrive/e/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/app/user&apos;make[2]: Leaving directory &apos;/cygdrive/e/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/app/user&apos;make[2]: Entering directory &apos;/cygdrive/e/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/app/driver&apos;make[2]: Leaving directory &apos;/cygdrive/e/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/app/driver&apos;!!!SDK_PATH: e:/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_templateBIN_PATH: e:/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/binNo boot needed.Generate eagle.flash.bin and eagle.irom0text.bin successully in BIN_PATHeagle.flash.bin--------&gt;0x00000eagle.irom0text.bin----&gt;0x20000!!!make[1]: Leaving directory &apos;/cygdrive/e/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/app&apos;23:48:37 Build Finished (took 4s.472ms) 后记这篇说的可能看起来有点云里雾里。因为和平时大家用的的不需要自己编写编译规则的IDE不同。像keil的话你添加的头文件也需要的手动添加到工程的IncludePath里面去。但是用这个eclipse开发esp8266完全使用makefile控制的，你的目录，头文件，c文件都是需要你手动配置makefile的，道理都一样都是要告诉编译器怎么去编译链接文件。不过是你自己找到makefile添加而已。之后会专门有一篇大概说一下整个工程如果我们想添加新的功能文件夹(比如实现一个tcp客户端功能)，我们怎么去修改makefile。有什么疑问欢迎联系我。]]></content>
      <categories>
        <category>ESP8266</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ESP8266工程的导入]]></title>
    <url>%2F2018%2F01%2F22%2FESP8266%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%AF%BC%E5%85%A5%2F</url>
    <content type="text"><![CDATA[前言：本篇文章主要讲一下，ESP8266的工程怎么导入到Eclipse里。 准备一个SDK工程 既然是导入那么你首先得有一个现有的工程(不存在建工程的，这辈子都不可能徒手建工程的)，工程从网上找一个就OK了。 ESP8266的SDK有两种，一种是无系统(NON-OS SDK)，另一种是运行了FreeRTOS的(RTOS SDK)。 SDK类型描述优缺点NOn-OS SDK1.主要使⽤定时器和回调函数的⽅式实现各个功能事件的嵌套，达到特定条件下触发特定功能函数的⽬的。2.使⽤ espconn 接⼝实现⽹络操作，⽤户需要按照 espconn 接⼝的使⽤规则进⾏软件开发.1.无系统，顺序执行好理解占用资源少，但是不能有while(1);2.不能有超过10ms的阻塞(延时)发生，否则将会重启。RTOS SDK1.用户可以使⽤FreeRTOS 的标准接⼝实现资源管理、循环操作、任务内延时、任务间信息传递和同步等⾯向任务流程的设计⽅式;2.⽹络操作接⼝是标准 lwIP API，同时提供了 BSD Socket API 接⼝的封装实现，⽤户可以直接按照 Socket API 的使⽤⽅式来开发软件应⽤，也可以直接编译运⾏其他平台的标准 Socket 应⽤; 3.引⼊了 cJSON 库，使⽤该库函数可以更加⽅便的实现对 JSON 数据包的解析;4.兼容 non-OS SDK 中的 Wi-Fi 接⼝、SmartConfig 接⼝、Sniffer 相关接⼝、系统接⼝、定时器接⼝、FOTA 接⼝和外围驱动接⼝，不⽀持 AT 实现。1.有系统，通过任务的调度完成系统的运行，可以有延时。2.但是资源占用较多。 例子可以从乐鑫官方的下载地址下载.在下图所在的网页上面有选项选择ESP8266EX之后可以从下图所示的界面选择你所需要的SDK。 点击右边的下载按钮会跳转到GitHub(需要你懂一点点的git的知识才能下载)。如果实在没办法的话(求求你学一点git吧)，我把我写文章的时候的最新的上传到网盘，大家可以去下载 链接: https://pan.baidu.com/s/1c39VpXQ 密码: dup8 。 下载下来解压到你想放置的目录，不要有中文和(空格?)，这样工程就完成了初步的布置。接下来就是重头戏了。导入工程 第一步:应该能想到吧，那就是打开Eclipe_IDE(不会打开就算了你不适合用电脑)。 第二步:打开eclipse之后会出现欢迎界面:”Welcome to the Eclipse IDE for C/C++ Developers”。 第三步:点击 工具栏-&gt;File-&gt;Import (如图)进入导入工程窗口。 第四步:在select窗口选择C/C++-&gt;Existing Code as Makefile Project-&gt;点击Next进行下一步 第五步:Import Existing Code 窗口选择浏览你的工程路径(就是解压出来的文件的路径)-&gt;下方选择 Cygwin GCC 工具-&gt;再点击Finish按钮完成导入。如果在这一步发现没有Cygwin GCC选项回头去检查是否用Eclipse_IDE.exe选择了正确的 Cygwin 路径。 第六步:这时候你会发现，什么都没出现！怎么办？，那就是把欢迎界面叉掉！这样在右边Project栏就能发现一个折叠的工程，点击可以展开，整个界面大致如下图。我的因为是用git直接克隆下来的，所以在工程名旁边会提示橙色的字。如果你是从百度云下载的那就没有，这个无需理会，都一样(牛逼吧，git)。这时候问题输出窗口应该是什么都没有的，如果提示什么找不到g++、make等等，返回去检查是否选择的工具是Cygwin GCC！！！。后记我们都是用别人的工程(Demo)上开发的，所以这一步属于比较基础的，我们导入进来之后应该是编译通不过的！为什么，因为我们的SDK路径和写Demo的人不一样。这个涉及到makefile的编写了，不过别人已经把整个makefile编写的比较”智能”了，我们只是想要编译成功的话其实是不需要懂makefile的。我们改一改SDK的路径就行了。这个下一节再讲。 附录乐鑫官方的快速上手指导文档在上一篇-&gt;后记 里有网盘链接在这里就不放了。里面有SDK文件目录的讲解7/31页，看一下便于后面理解。 我整理了一下： RTOS SDK工程目录讲解 bin：编译⽣成的 BIN 文件，可直接下载到 Flash 中。 documents：SDK 相关的⽂档(RTOS api)或链接。 driver_lib：乐鑫官方提供的驱动示例代码。(IIC SPI GPIO等) examples：可供用户二次开发的示例代码。(我们把不要的删掉) openssl_demo：乐鑫官方提供的 OpenSSL 接口功能示例代码。 project_template：乐鑫官方提供的工程模板示例代码。(我们用这个，其他的以后再说) smart_config：乐鑫官⽅提供的 SmartConfig 功能示例代码。 spiffs_test：乐鑫官方提供的 SPIFFS 文件系统功能示例代码。 websocket_demo：乐鑫官方提供的 WebSocket 功能示例代码。 include：SDK 自带头文件，包含了用户可使⽤的相关 API 函数及其他宏定义，用户无需修改。 ld：链接时所需的脚本文件，如⽆特殊需求，用户无需修改。(根据这个可以生成多钟bin文件) lib：SDK 提供的库文件。(只能用api不能改不能看) third_party：乐鑫开放源代码的第三方库，当前包含FreeRTOS、JSON、LWIP,mbedTLS、noPoll、OpenSSL、SPIFFS 和 SSL。 tools：编译 BIN 文件所需的工程具，用户无需修改。 Non-OS SDK工程目录讲解 bin：编译⽣成的 BIN 文件，可直接下载到 Flash 中。 documents：SDK 相关的⽂档或链接。 driver_lib：外设驱动的库文件，如：UART、I2C 和 GPIO 等。 examples：可供用户次开发的示例代码，如 IoT Demo 等。 include：SDK ⾃带头文件，包含了用户可使用的相关 API 函数及其他宏定义，用户无需修改。 ld：链接时所需的脚本文件，若无特殊需求，用户⽆需修改。 lib：SDK 提供的库文件。 tools：编译 BIN 文件所需的工具，用户无需修改。]]></content>
      <categories>
        <category>ESP8266</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ESP8266开发环境的搭建]]></title>
    <url>%2F2018%2F01%2F21%2FESP8266%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[前言：本篇文章主要讲一下，ESP8266的开发环境怎么搭建。 开发工具下载:对于ESP8266的开发工具我们采用的是eclipse搭建的一个IDE。这是安信可公司开发出来的，他们公司还出了一款付费的，只需要点一点就能生成基础代码的工具(不付费只能生成代码不能编译)。点击这里下载最新的IDE。这里最新更新是2016年，应该已经停止了更新。防止链接失效，我转存到我的网盘：ESP8266开发环境 密码: qnkh。如果我的失效了请联系我更换。 开发环境搭建步骤当你忍受了百度云限速下载完成后恭喜你最艰难的一步完成！下载之后的会有四个文件：文件 |说明— |—cygwin.exe | cygwin和xtensa编译器环境Eclipse.exe | eclipse c/c++ 开发工具打包ESP_IDE.exe | 一体化开发环境(配置)工具下载前读我！！！.txt|就是说明文档和教程(我的教程意义何在!!!) 我们要把下载的文件放到你想要放的位置该位置必须不能有空格(cygwin目录不能有空格)，我一开始放在了放在了”D:\Program Files\ESP8266IDE\” 目录下导致后面没法选择 cygwin。最后我选择放在 “D:\ESP8266IDE\”， 点击打开cygwin.exe和Eclipse.exe进行自解压到当前目录，解压完成之后会在生成两个目录，”cygwin 和 eclipse”。 点击ESP_IDE.exe运行，选择cygwin目录和eclipse目录。同时右下角的Not Ask也勾选，这样下次就不会再次弹出来让你选择path。如果出问题了删除ESP_IDE.exe同级目录-&gt;config-&gt;cfg.xml，再次打开就会提示你选择。 首次运行会提示选择工作空间的路径。自己建一个目录选择就OK了,我选择”D:\ESP8266IDE\workspaces”,勾选下面的选项下次就不会弹出来让你选了。(备注：一个工作空间可以同时打开很多个工程，不是每一个工程都需要打开一次IDE)。 完成搭建这样就完成了开发环境的配置了，是不是感觉有点简单的过分。把cygwin.exe、Eclipse.exe删除节省空间。最后，别忘了把ESP_IDE.exe创建一个快捷方式到桌面(不懂的…)，这样你下次直接点击就能打开eclipseIDE了。 后记 还有另外一种使用ubuntu镜像进行编译的方式，不过没有这种方便所以就不介绍了(官方有一个文档可自行去乐鑫下载也可下载我上传到网盘的链接:https://pan.baidu.com/s/1ggMazRl 密码: g3y3 ,在第9/31页开始讲。所以感谢安信可公司的奉献，让我们可以省去使用官方ubuntu镜像编译的开发方式！撒花ing… arduino IDE工具，这个也可以开发，不过我并不喜欢arduino所以我一眼都没看过23333。 附录 乐鑫公司官方文档资料、工具、demo下载地址:http://espressif.com/zh-hans/support/download/overview. 安信可公司官方的资料地址:http://wiki.ai-thinker.com/esp8266. 开发快公司提供免费的ESP8266模组的申请:http://bbs.kaifakuai.com/thread-981-1-1.html,注册之后就可以申请(我当时就是因为申请到了才开始玩ESP8266的，虽然很便宜但是抵不住他不要钱啊！！！).当然他们公司资料也很多的也很活跃，大家可以到处逛逛。开发快官方开发平台:http://developer.kaifakuai.com。QQ群:445880047。]]></content>
      <categories>
        <category>ESP8266</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ESP8266开发历程前言]]></title>
    <url>%2F2018%2F01%2F21%2FESP8266%E5%BC%80%E5%8F%91%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[意义：这算是第一个教程吧，ESP8266从大三到现在学了到现在，但是没有什么记录。回头又得拿着代码一点一点看，所以打算记录一下。同时也会兼顾一些解释和教程性质的东西，给能找到这的人看看吧，希望能给你一点帮助。 更新：更新的话，不定时。至于内容的顺序，就先按照一个hello world的实现来写，从引脚，IDE，下载工具，接线到写hello world，到下载查看。这些讲完的话打开你也就懂怎么做了。但是我不会写IO的使用因为我觉得他的定位作为wifi芯片比较好，就不要掺杂其他的的东西了(个人看法)。后面的软件层面的实现(主要是网络通信的应用)的话，也会写一部分。不过感觉网上其实挺多的教程(比较零散)，所以不排除会直接把比较好的搬运过来然后配合自己的理解说一下。]]></content>
      <categories>
        <category>ESP8266</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux系统目录讲解]]></title>
    <url>%2F2017%2F12%2F06%2Ffile%20system%2F</url>
    <content type="text"><![CDATA[/bin 目录 全称：Binary(Binaries) 作用：存放二进制可执行文件，例如命令行的cp命令。 备注：/bin下的命令是所有用户都可以执行的。/sbin(Spuer Binary)目录下的命令只有超级用户权限才能执行，比如分区操作。 /boot 目录 全称 ：Boot 作用 ：存放操作系统的引导启动需要的文件。一般100M左右(50~200)。 备注 ：里面存放的vmlinuz…文件就是操作系统的内核文件，他名字就是版本号。通过bash运行 uname -r可以看到系统的版本。grub引导同样在/boot下。 /dev 目录 全称 ：Device 作用 ：把计算机的硬件抽象为文件存储在/dev下面。诸如硬盘(hd×),处理器(cpu),网卡(net),usb等等。 /etc 目录 全称 ：Etcetera(其他)/Editable Text Configuration(可编辑配置文本) 作用 ：保存几乎所有的配置文件，系统的各个服务、组件、软件的配置文件存放地方，一般以.cnf或.conf结尾(configure)。 /home 目录 全称 ：Home 作用 ：存放除root用户之外所有用户的’家目录’的目录。 也就是每一个用户都会在/ｈome下有一个对应用户名的目录，用于存放该用户的私有数据。比如系统里有一个begild用户，那么/home下必有一个Beild文件夹。/home/begild下存放自己的桌面、文档等。 /lib 目录 全称 ：Library(Libraries) 作用 ：linux系统运行需要的共享库文件，相当于windows的.DLl文件(动态链接库)。一般以 .so (shared object)结尾。 备注：同样的还有/lib32、/lib64两个文件夹，作用和/lib相同，只是运用于32位还是64位。 /lost+found 目录 全称 ：lost+found 作用 ：用于存放系统发生错误的时候遗失的文件。 备注 ：只有root权限才能访问 /mnt 目录 全称 ：Mount(挂载) 作用 ：其他文件系统挂载的挂载点。使用mount命令挂载(手动挂载)。 备注 ：具备同样作用的还有/media目录，不过media目录一般用于实现自动挂载。 /opt 目录 全称 ：Optional application software packages(可选的应用程序) 作用 ：存放第三方、大型、版权保护的软件、游戏。 备注 ：安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。 /proc 目录 全称 ： 作用 ：存放进程信息，内核信息，内存使用等等快速变化的’文件’的目录。 备注 ：它本身不存在于实际的文件系统里。他是一种虚拟的文件系统。例如我们通过cat /proc/cpuinfo命令可以打开cpuinfo文件。里面完整的描述了cpu的信息。 /root 目录 全称 ：Root 作用 ：root用户的家目录，其他的用户家目录位于/home下。 /tmp 目录 全称 ：temp 作用 ：存放系统的临时文件,例如压缩文件预览.关机会自动清理,手动清理用tmpwatch命令. /usr 目录 全称 ：unix software resource 作用 ：软件安装的目录. /var 目录 全称 ：variable 作用 ：存放系统/软件运行过程中产生的缓存,登录日志等等文件.]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux目录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C函数指针]]></title>
    <url>%2F2017%2F10%2F28%2FC%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[当我们看到如下所示的代码怎么去理解它的意义呢。1(* ( void (*) () ) 0) () 解析这个函数需要下面几个知识 函数申明包含返回值，函数名，参数列表。 如返回值是’int’ 函数名为’fun’,参数列表为’void’。 1int fun(void); 函数指针和返回值为指针的函数 函数指针:函数指针pfun指向的是一个返回值为int类型，参数列表为空的函数。只要是符合这个’形状’的函数都可以吧地址赋给pfun。 1int (*pfun) (void); 返回值为指针的函数:返回值为int*类型的指针，参数列表为空的函数fun1。它表示fun1是一个确定的函数。不像pfun是可以指向任何符合模板的函数。 1int* fun1 (void); 所以在书写的时候必须注意是否需要加括号。 类型转化符。就像我们平时说的怎么把一个int强制转化为char呢，就是 12int a = 48;char b = (char) a; 我们怎么构建一个类型转化符呢，就是把目标类型用括号括起来，那么一个函数模板的类型转化符是怎么样的呢，就是把函数名去掉，然后用括号把他括起来。比如上面的函数指针pfun这个模板。我们只需要将pfun去掉，然后把剩下部分括起来。 1(int (*) (void) ) 这就是一个返回值为int参数列表为空的函数指针的强制类型转化符。 完成上述理解之后，我们着手理解一下1(* ( void (*) () ) 0) () 首先通过下面这个式子可以看出这是一个函数的调用，那么左括号里面的就是函名。1( funname ) () 也就是 1* (void (*) () ) 0 == funname 把0强制类型转化为void (*) () 型的函数指针。也就是指向函数地址为0的指针 1(void (*) () ) 0]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试编译器是否支持嵌套注释]]></title>
    <url>%2F2017%2F10%2F01%2F%E6%B5%8B%E8%AF%95%E7%BC%96%E8%AF%91%E5%99%A8%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%B5%8C%E5%A5%97%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"><![CDATA[问题：某些C编译器允许嵌套注释。请写一个测试程序，要求：无论是对允许嵌套注释的编译器，还是对不允许嵌套注释的编译器，该程序都能正常通过编译（无错误消息出现）， 但是这两种情况下程序执行的结果却不相同。 提示： 在用双引号括起的字符串中， 注释符 /* 属于字符串的一部分，而在注释中出现的双引号 “ “ 又属于注释的一部分。 出自——《C陷阱与缺陷》练习1-1 嵌套注释：顾名思义就是注释里嵌套着注释。比如1/*"/*"*/"*/ 对于这段代码，不同的编译器识别的结果不同： 我们如何通过代码的输出判定编译器是否支持嵌套注释呢，重点就是让同一段代码，支持嵌套注释的编译器和不支持嵌套注释的编译器注释掉不同的地方。根据题目的提示字符串中的 /* 是属于字符串的一部分，比如 “/*aa*/“ 这里面的注释标号编译器是不会理会的，而 /*“aa*“/ 这里面的 “aa” 是不会识别为字符串的。还有一点无论是 “ “ 还是 /**/都是就近匹配的。 我们首先构建一个嵌套的注释，这个注释在支持嵌套注释的编译器里能编译通过，而在不支持的编译器里编译失败：1/*"/*"*/"*/ 不支持的系统中出现了”*/“导致编译失败 我们通过添加一个 “ 使得不支持的系统编译成功1/*"/*"*/"*/" 可以看出这样添加之后不支持的编译器已经能编译成功并且有输出一字符串，支持的系统由于多了一个 “ 导致编译失败，根据题目提示我们构建一个字符串” “并且”/*,*/“ 两两配对，所以我们添加一个 /*形成”/*“ 1/*"/*"*/"*/"/*" 这样操作之后支持/不支持的编译器输出不同的字符串(蓝色部分),但是不支持的编译器多了 /* “编译失败，而它刚好又是多行注释的头,所以我们得加一个尾 */ 使得他们配对。1/*"/*"*/"*/"/*"*/ 我们从上图可以看出不支持嵌套注释的编译器已经能通过编译并且有区别去支持嵌套注释的编译器的输出。但是支持嵌套注释的编译器由于多了*/导致编译失败，因为不支持嵌套注释的编译器的注释之间无论是什么都可以忽略，所以我们在最后的 */ 之前加一个 /* 让支持嵌套注释的编译器能找到配对的注释对。1/*"/*"*/"*/"/*"/**/ 通过上述步骤我们找到了一个合适的语句使得在两种编译器中编译成功并且有不同的输出。 通过一段简单的代码我们可以看下效果 1234567891011121314151617#include &lt;stdio.h&gt;int ISSupNestComment(void);int main()&#123; printf("This compiler %s support nested comment \r\n", ISSupNestComment()? "": "does not"); return 0;&#125;int ISSupNestComment()&#123; char *Str=/*"/*"*/"*/"/*"/**/; if(Str[0]=='*')//"*/"不支持嵌套注释 return 0; else //"/*"支持嵌套注释 return 1;&#125; 自己做完这个感觉还是有点意思的，上网搜了一波，发现别人想的更是精妙。不禁发出一套赞赏三连，卧槽牛逼666。下面我们看下一大佬们是怎么做的。 1.Doug McIlroy1/*/*/0*/**/1 这个解法主要利用了编译器作词法分析时的“大嘴法”规则。编译器支持嵌套注释，则上式将被解释为1.编译器不支持嵌套注释，则上式将被解释为 0*1. 2.TimWu1234567891011#define A /* aaa /* a*/ a#define B */bool CanNesting()&#123;#ifdef B return false;#else return true;#endif&#125; 他利用的多行注释和宏定义的特性，编译器支持嵌套注释宏定义B则会被注释掉导致没有宏定义B。编译器不支持嵌套注释，宏定义B则会定义为 */。通过预编译判断就可以输出结果。]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>嵌套注释</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理器大小端存储模式]]></title>
    <url>%2F2017%2F09%2F13%2F%E5%A4%A7%E5%B0%8F%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[大端模式：是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。 小端模式：是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。 例如：一个数据无符号32位整数0x12345678,其中0x12属于高字节(权值大)而0x78属于低字节(权值小),在不同的模式下存储的方式如下表： 内存地址 0x1000 0x1001 0x1002 0x1003 大端模式 0x12 0x34 0x56 0x78 小端模式 0x78 0x56 0x34 0x12 我们可以看得出来大端模式和我们的阅读习惯相同，权值从左往右是高位-&gt;低位而地址则是低位-&gt;高位。小端模式则是随着地址从左往右增大权值增大。地址就代表了权值的大小。 利用下面c代码可以看到运行环境是如何存储一个uint数据的。 12345678910111213#include &lt;stdio.h&gt;int endian(void);int main(int argc,char arg[])&#123; unsigned int a=0x12345678; char *ap=&amp;a; int i=0; printf("0x%x storage in system is:\r\n",a); for(i=0;i&lt;4;i++) printf("addr:0x%x,value:0x%x\r\n",ap+i,ap[i]); printf("system storage by %s_endian",endian()? "Big":"Little"); return 0;&#125; 运行的结果如下，可以看出该系统是小端系统。 我们如何简单的判断一个系统的大小端呢。我们知道共用体(联合体)存储在内存里是共用一块地址的，其占用空间决定于最大成员所需的空间,他们的起始地址相同。所以我们可以利用一个共用体,成员分别是一个int和一个char。通过给int赋值1，然后检测char对应的值是多少，如果是1代表系统将数据1放到了int的起始地址(因为char是一个字节必然在起始地址)。而起始地址是低地址，低地址存放的1(权值小)推出该系统是小端系统。否则该系统是大端系统。 C代码如下1234567891011int endian()&#123; union&#123; int a; char b; &#125;endunion; endunion.a=1; if(endunion.b==1)//如果成员b是1则证明随地址顺序和数字权值顺序相同是小端模式 return 0;//小端 return 1;//大端&#125; 还可以用一个更加简洁的办法(原理都是检测int的起始地址存放的是什么值)，代码如下12345int endian()&#123; int a=1; return !(*((char *)&amp;a));//取a的地址，将其强制转化为char指针，然后取出该地址存放的值并取反;&#125;]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>大小端存储</tag>
      </tags>
  </entry>
</search>
