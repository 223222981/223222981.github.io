<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[科学上Google]]></title>
    <url>%2F2018%2F04%2F22%2FKeXueShangWangJiaoCheng%2F</url>
    <content type="text"><![CDATA[写在前面 如果你在在搜索资料方面在百度遇到了巨大挫折，我相信google能解决你问题。 在我个人看来百度适用于找贴近于生活常识简单的东西(当然你必须具备一定的辨识能力不要盲目相信，莆田系的惨剧不是不能重演)，就这些知识而言相对于google来说是比较好的。 在专业的知识方面百度对于google来说就是个孤儿。搜索来的东西词不达意，胡扯一通或者根本就没有相关有用的东西(有用的怕就是 CSDN 了其他的都是狗屁不通)。 google搜索来的，基本如果是教程，数据手册，书本什么的前4条就能找到你要结果，属于比较专业的。我第一用google搜资料是因为百度实在是找不到那个芯片的数据手册(或许是我太菜了没能拨开那层层的迷雾)，那时候改一改 host 还是上了 google 的，一搜索第2条就是角标一个pdf字样，直接下载就是数据手册，从那以后我越发的觉得百度就是个傻逼。 后来 老D博客 给的 host 也时常不能用，不过后来有幸免费得了一个绿皮车的账号福利，滴滴滴成功上车。 用了没多久觉得也不是很稳定，后来就决定自己学习搭一下然后就上google搜了一下搭建教程(境外访问) 通过这个教程也成功的自己开了车~，然后在这里记一下。 刘冰洋一审刑事判决书 科学上网胖虎劝你谨言慎行，头脑清晰，高举社会主义伟大旗帜，坚决拥护中国共产党。 关于中国的互联网网络审查在各个国家都普遍存在着，它并不仅存在于中国。在全球的局势对中国都不利的当下，当局会过滤掉影响、危害到中国长远发展的信息，此时国家安全的意义更加重大。 互联网上存在着大量终究不现实的、不客观的，甚至自相矛盾的抹黑当局政府言论，它们背后一般有西方政府或非政府组织资金支持。这些媒体包括但不限于一些港媒、境外网站。 我们希望您能在遇到此类言论和见解时，不要不加思考地、情绪一度被煽动而不能克制地、盲目地相信这些片面或者歪曲事实的东西，而是要事实求是地思考，要摆脱情绪绑架的怪诞思维去理解。 我们需要了解到，中国的发展总基调是“稳中求进”，中国社会的最核心问题就是稳定。失去稳定的中国将会是一盘散沙，面临分裂和肢解的危险。我们希望您了解当今中国发展的根本保证是什么，发展的过程中哪部分是主旋律，哪些是噪音；哪些是进取的，哪些是会开历史倒车的。我们需要维新，而不是革命。 我们应该清醒和全面地认识问题，偏信西方媒体的言论、缺乏对国家的信任是不可取的。您的数据安全和隐私对您尤为重要。若这些信息不应当被西方掌握时，它对国家和民族的命运更为重要。出于此原因，当局可能会限制您的行为，我们不会也无法干预当局的任何政策和决定。 所以，我们希望您在使用此服务时，不要盲目地攻击当局的做法。原文(https://github.com/racaljk/hosts/wiki/关于中国的互联网) 搭建步骤1 购买vps 购买一台 Vultr 主机，便宜😉稳定😉。https://www.vultr.com/?ref=7288720 点击这个链接即可注册（注意：如果关闭网页再从历史记录中打开则无效，所以如果不小心关闭了可以再点击上面的链接注册），在你通过这个链接注册并在30天内充值10美元的话我也会得10美元。vultr支持支付宝支付，最少面额是10美元🤙 。密码必须包含大写字母小写字母数字，长度至少10位。注册完毕即可登录。第一次登录会发送一个验证邮箱的邮件到邮箱。 登录成功，点击在侧边栏的 Billing ，在主页面的支付选项里可以选择多种方式，在这里可以使用 Alipay 支付，也就是我们所说的支付宝。点击右边会有快捷金额出现，最小的面额就是10美元，点击下方支付按钮会自动生成支持二维码，扫描即可支付。到账有可能有延迟，等一下就好了。到账之后会在右上角出现你的余额。 完成支付之后。点击在侧边栏的 Servers ，选择服务器在的位置(我选的Miami)；运行的系统(Debian 7 x64 不要选错了)；配置(2.5美元档位) ；附加功能勾选使能 IPV6。点击最下方的 Deploy Now 就成功购买了服务器了。这个2.5美元的配置属于最低的，有可能Maimi买不到，你得尝试尝试其他地点看有没有该配置。都没有就尝试5美元的吧。他这个扣费并不是一次性扣费一个月，是按照使用时长的，比如你先买了5美元的用了1个小时后发现可以买2.5美元的，那么你把这个服务器销毁了他就只扣费1个小时的钱，这点还是比较好的。 点击侧边的 Servers ，在主页面就会出现你刚购买的服务器了，等到显示绿色的 running 时候就部署完成了。点击下图所指的Debian OS图标即可进入服务器的详情界面，。 详情界面可以看到详细的 IP、用户名、登录密码、CPU、RAM、硬盘大小、流量使用情况等等。我们主要用到用户名和密码待会远程登录需要使用。 搭建步骤2 远程登录 任何一个支持远程的工具都可以，这里选择 putty 点击下载 体积很小，安装选项默认就行了，位置随便你。然后会在开始菜单有一个 PuTTY 图标，点击即可打开 putty 在①填服务器的IP、②填你想要保存的名字，比如科学上网；点击save保存下次就不用输入了；双击即可弹出登录窗口。可能界面比较难看，字还很小，将就一下或者自己改一下。 在弹出的 login as: 填写上面服务器详情页显示的 Username (默认就是 root) ，密码填一下详情页的 Password 点击详情页那里的复制按钮即可复制，在 putty界面 右键一下自动粘贴，不需要一个一个输入，如果失败那就是你操作有问题，实在不行老老实实的输，不过这里是看不到任何的密码提示的连 * 都没有。 登录成功即显示出linux终端的样式 root@vultr:~# 。 搭建步骤3 刷入Shadowsocks 第一段代码，下载一键安装脚本。直接复制到 putty 里，右键直接粘贴，后回车运行即可， 1wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh 结果展示： 123456789Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 151.101.4.133Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.4.133|:443... connected.HTTP request sent, awaiting response... 200 OKLength: 44802 (44K) [text/plain]Saving to: `shadowsocks-all.sh&apos;100%[======================================&gt;] 44,802 --.-K/s in 0.002s2018-04-22 13:43:08 (17.3 MB/s) - `shadowsocks-all.sh&apos; saved [44802/44802] 第二段代码如下，赋予下载来的脚本执行权限。同样复制右键粘贴到 putty 回车运行。没有任何报错即可。 1chmod +x shadowsocks-all.sh 第三段代码如下，执行一键安装脚本(感谢 秋水逸冰 提供)。 1./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log 执行的选择过程大致如下 已经标注了需要注意的点和注释: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273Which Shadowsocks server you&apos;d select:1) Shadowsocks-Python2) ShadowsocksR3) Shadowsocks-Go4) Shadowsocks-libevPlease enter a number (Default Shadowsocks-Python):2 (选择 ShadowsocksR)You choose = ShadowsocksRPlease enter password for ShadowsocksR(Default password: teddysun.com):（密码）password = ***Please enter a port for ShadowsocksR [1-65535](Default port: 9555):（端口）port = ***Please select stream cipher for ShadowsocksR:1) none2) aes-256-cfb3) aes-192-cfb4) aes-128-cfb5) aes-256-cfb86) aes-192-cfb87) aes-128-cfb88) aes-256-ctr9) aes-192-ctr10) aes-128-ctr11) chacha20-ietf12) chacha2013) salsa2014) xchacha2015) xsalsa2016) rc4-md5Which cipher you&apos;d select(Default: aes-256-cfb):12（选择chacha20 rc4-md5速度较快不过相对于aes安全性不高，chacha20效率比aes高加密性相当）cipher = chacha20 Please select protocol for ShadowsocksR:1) origin2) verify_deflate3) auth_sha1_v44) auth_sha1_v4_compatible5) auth_aes128_md56) auth_aes128_sha17) auth_chain_a8) auth_chain_b9) auth_chain_c10) auth_chain_d11) auth_chain_e12) auth_chain_fWhich protocol you&apos;d select(Default: origin):3 (使用 auth_sha1_v4 协议 较高安全性，混淆强度大)protocol = auth_sha1_v4Please select obfs for ShadowsocksR:1) plain2) http_simple3) http_simple_compatible4) http_post5) http_post_compatible6) tls1.2_ticket_auth7) tls1.2_ticket_auth_compatible8) tls1.2_ticket_fastauth9) tls1.2_ticket_fastauth_compatibleWhich obfs you&apos;d select(Default: plain):2(混淆采用 http_simple) obfs = http_simplePress any key to start...or Press Ctrl+C to cancel (按下任意键开始刷入 ctrl+C 取消) 执行成功结束会吧你整个 Shadowsocks 的配置打印出来，大致如下，将这段东西复制粘贴在记事本里备份一下免得以后忘了。 123456789101112131415161718Starting ShadowsocksR successCongratulations, ShadowsocksR server install completed!Your Server IP : ************* （服务器IP）Your Server Port : ***** （服务端口） Your Password : ********* （使用的密码）Your Protocol : auth_sha1_v4 （使用的协议）Your obfs : http_simple （混淆协议）Your Encryption Method: chacha20 （加密方式）Your QR Code: (For ShadowsocksR Windows, Android clients only) ss://****************************************************** (SS配置信息代码，复制到小飞机右键剪切板批量导入)Your QR Code has been saved as a PNG file path: /root/shadowsocks_r_qr.png (SS配置信息二维码)Welcome to visit: https://teddysun.com/486.htmlEnjoy it! 本地 SSR 客户端的配置，下载地址。 下载完成之后，解压到你想放置的文件夹下就好了。会有两个启动程序 2.0 和 4.0，分别是依赖于 NET Framework v2.0 和 v4.0 ，功能无区别随便打开一个就OK。 打开在任务栏会有小飞机图标显示。这时候复制上面服务器输出的 SSR 配置信息代码，也就是ssr://****** 那一大串，全部复制。在小飞机上右键弹出的菜单里找到 剪切板批量导入ssr://地址... 选项，点击该选项即完成导入配置。 这时候的配置大致如下，可以看到混淆参数、备注和群组都是空的。混淆方式选择的是 http_simple 的话，参数里就填你要伪装的域名，也就是你的流量会被伪装成向你填写的域名请求的流量，减少被检测的风险，我填的是cdn.4g.play.cn,4gmv.music.189.cn,dl.music.189.cn。备注和群组就不多说了就是一些方便分类记忆的信息(毕竟有些人有很多车)。填写完成你的整个 ssr:// 也会改变，以后分享给别人就直接复制这个 ssr代码，别人贴上去是和你的一模一样的。 这样就完成了搭建。访问 Google 试一下，没问题的话等下就加载出来了。 搭建步骤4 刷入锐速进行提速首先你可以尝试运行这个命令，如果没有报错。那么你很幸运不用执行下面复杂的操作。如果有报错不支持你的内核那么你就得需要执行后续的步骤。1wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder.sh &amp;&amp; bash serverspeeder.sh 错误信息大致如下:1234567891011===============System Info=======================Debian3.2.0-5-amd64x64=================================================巴拉巴拉。。。2018-04-22 15:05:11 (21.0 MB/s) - `serverspeederbin.txt&apos; saved [96179/96179]&gt;&gt;&gt;This kernel is not supported. Trying fuzzy matching...Serverspeeder is not supported on this kernel! View all supported systems and kernels here: https://www.91yun.org/serverspeeder91yun 上面代码执行出问题参照下面步骤解决。 锐速并不是支持所有的内核，支持列表见 锐速支持内核列表 该列表里找到 Debian7 x64 部分的内核列表大致如下，该列表仅供参考，具体的到上面的链接内核支持列表里查看： 1234567891011Debian/7/3.12-1-amd64/x64/3.10.54.8/0/serverspeeder_2483Debian/7/3.12-1-amd64/x64/3.10.61.0/0/serverspeeder_2609Debian/7/3.2.0-4-amd64/x64/3.10.39.8/0/serverspeeder_2010Debian/7/3.2.0-4-amd64/x64/3.10.53.0/0/serverspeeder_2323Debian/7/3.2.0-4-amd64/x64/3.10.54.8/0/serverspeeder_2466Debian/7/3.2.0-4-amd64/x64/3.10.61.0/0/serverspeeder_2626Debian/7/3.2.0-4-amd64/x64/3.9.10.41/0/serverspeeder_1662Debian/7/3.2.32/x64/3.10.45.0/0/serverspeeder_2154Debian/7/3.2.32/x64/3.10.53.0/0/serverspeeder_2289Debian/7/3.2.32/x64/3.10.54.8/0/serverspeeder_2443Debian/7/3.2.32/x64/3.10.61.0/0/serverspeeder_2599 执行如下代码查看服务器的内核列表 。 1dpkg -l|grep linux-image | awk &apos;&#123;print $2&#125;&apos; 我的结果如下： 1234root@vultr:~# dpkg -l|grep linux-image | awk &apos;&#123;print $2&#125;&apos;linux-image-3.2.0-4-amd64linux-image-3.2.0-5-amd64linux-image-amd64 锐速支持的内核列表里有3.2.0-4 所以我这里直接找到对应的链接就行了，我选了个锐速版本最高的 3.10.61.0 。如果你的内核列表里没有与锐速所支持的内核所匹配的项，那你就需要刷入一个匹配的内核。 (内核问题参照于笨猫博客)3.1 添加软件包源并更新软件包列表。 12echo -e &quot;\ndeb http://ftp.debian.org/debian/ wheezy-backports main&quot; &gt;&gt; /etc/apt/sources.list apt-get update 3.2 查看所有的内核列表 1234567891011121314151617root@vultr:~# aptitude search linux-image | awk &apos;&#123;print $2&#125;&apos;结果如下：linux-imagelinux-image-2.6-amd64linux-image-3.16.0-0.bpo.4-amd6linux-image-3.16.0-0.bpo.4-amd6linux-image-3.2.0-4-amd64linux-image-3.2.0-4-amd64-dbglinux-image-3.2.0-4-rt-amd64linux-image-3.2.0-4-rt-amd64-dblinux-image-3.2.0-5-amd64linux-image-3.2.0-5-amd64-dbglinux-image-3.2.0-5-rt-amd64linux-image-3.2.0-5-rt-amd64-dblinux-image-amd64linux-image-amd64-dbglinux-image-rt-amd64 3.3 选择 linux-image-3.2.0-4-amd64 进行安装,这个会下载几百M的文件，耐心等待。 1apt-get -t wheezy-backports install linux-image-3.2.0-4-amd64 -y 3.4 下载安装完成之后再查看一下服务器的内核列表，有 linux-image-3.2.0-4-amd64 就OK了。 卸载其他的内核版本。比如我的就卸载 linux-image-3.2.0-5-amd64和 linux-image-amd64 两个。 1apt-get purge 其余内核名称 卸载的时候会弹出一个选择框，该框是让你选择是否中断移除。一定要选择右边的取消！！！。如果出现卸载提示互斥 dkbg 被占用之类的,重启一下服务器(reboot 命令)重连 putty 再执行就OK了。 更新 grub 系统引导文件并重启(会断开putty) 12345678root@vultr:~# update-grub &amp;&amp; rebootGenerating grub.cfg ...Found linux image: /boot/vmlinuz-3.2.0-4-amd64Found initrd image: /boot/initrd.img-3.2.0-4-amd64doneBroadcast message from root@vultr.guest (pts/0) (Sun Apr 22 16:14:40 2018):The system is going down for reboot NOW! 当解决了内核的问题之后就到了安装了。因为经过上述步骤之后内核已经变更为 linux-image-3.2.0-4-amd64 所以我们执行下面的命令就可以了。如果是其他版本的内核请点击 锐速支持内核列表 找到对应项点击进去获取你的执行代码。 1wget -N --no-check-certificate https://github.com/91yun/serverspeeder/raw/master/serverspeeder-v.sh &amp;&amp; bash serverspeeder-v.sh Debian 7 3.2.0-4-amd64 x64 3.10.61.0 serverspeeder_2626 安装过程如下: 123456789101112131415161718192021222324252627282930313233343536373839上接wget命令的输出===============System Info=======================Debian3.2.0-4-amd64x64=================================================installing ServerSpeeder, please wait for a moment...[Running Status]ServerSpeeder is running!version 3.10.61.0[License Information]License ***** (valid on current device)MaxSession unlimitedMaxTcpAccSession unlimitedMaxBandwidth(kbps) unlimitedExpireDate 2034-12-31[Connection Information]TotalFlow 1NumOfTcpFlows 1TotalAccTcpFlow 0TotalActiveTcpFlow 0[Running Configuration]accif eth0acc 1advacc 1advinacc 1wankbps 10000000waninkbps 10000000csvmode 0subnetAcc 0maxmode 1pcapEnable 0 搭建步骤5 刷入 Finalspeed 加速FinalSpeed 根据用户设定的网络带宽省略了确认的步骤或是延长了确认的间隔，服务器按照用户设定的速率持续高速发包，所以可以达到更高的速度。不过现在改为收费使用了名字也改为 tcpspeed 想要支持一下作者使用收费版本的请点击 http://www.tcpspeed.com/ ，省钱就使用旧版本的(作者已经删除)。91yun fork了一份并制作了一键安装包，项目地址 一键安装 FinalSpeed ,安装完成无报错即在运行。 1wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/finalspeed/master/install_fs.sh &amp;&amp; bash install_fs.sh 安装 FinalSpeed 客户端FinalSpeed 是双边加速，所以客户端这边也需要一个 FinalSpeed 客户端配合使用。下载地址 下载下来安装就行，它需要使用 winpcap 如果没有安装会提示你安装的根据需要选择是否开机自启 winpcap ，剩下的一路 next 完成就行了。 配置 FinalSpeed 客户端 在地址栏填上服务器的 IP 地址、设置带宽设置你服务器的带宽，因为测试过我的下载大概能到3000多Kb/s，所以我这里设置的下行带宽30M，上行带宽20M(瞎设的)。 点击右下的添加按钮，弹出的增加映射窗口。在名称编辑框填入你想要的描述、加速端口填你安装 SSR 时候写的端口、本地端口随便填一个，这个是用来和你的 SSR 客户端进行通信用的。填写完成自动生效的，关闭窗口就OK了。 配置 SSR 客户端，经过上面 SSR 的导入和配置已经可以成功 Google了。1.双击任务栏小飞机图标唤出配置窗口，点击左下角的添加按钮可以复制一份一刚刚导入的服务器配置信息。 在右边的配置栏服务器IP这里勾选显示并改为127.0.0.1 也就是本地回环地址。 服务器端口填写为你刚刚配置 FinalSpeed 的本地端口(这里 FinalSpeed 相当于是 SSR 的服务器)。 其他的重要信息不要改，备注和群组改一些方便识别。 这样就完成了 FinalSpeed 和 SSR 的联合配置，上网感觉可能不明显。但是看视频什么的就能看出差距了。没装 FinalSpeed 只能看 480P 装了之后，1080P 无压力。 SSR 客户端的使用SSR 客户端任务栏图标右键包含了整个软件的设置。 右键–&gt;选项设置–&gt;右上角可以设置开机启动。 右键–&gt;系统代理模式 选择各种不同的代理模式，IE代理，直连，PAC和全局，PAC指的是根据 PAC 列表选择是否通过 SSR 访问。全局就是所有访问均通过 SSR。我们选择 PAC 模式配合 PAC 文件进行使用。全局的话流量较高并且国内的访问用代理反而更慢。 右键–&gt;PAC 可以看到PAC的各种配置，这里给一个 PAC 文件的URL https://softs.fun/Other/pac.txt 点击 PAC 的配置里编辑本地 PAC 文件，将上述网页里的内容全选拷贝到改文件里覆盖保存即可。 右键–&gt;代理规则 使用绕过局域网和大陆。整个过程首先通过域名和 PAC 列表里匹配是否需要 SS R，如果需要 SSR 的话再通过代理规则判断该 IP 是否需要代理，如果需要的话服务器最终进行代理。 右键–&gt;服务器 选择你要的服务器。按照群组和备注来区分 默认是empty-group。该设置自动保存，下次打开自动使用。 其他的自己琢磨吧。可以看下这个 相关的一些指令1234567891011SSR 配置 vi /etc/shadowsocks-r/config.json（修改后需要重启SS）SSR 重启 /etc/init.d/shadowsocks-r restartSSR 状态 /etc/init.d/shadowsocks-r statusSSR 卸载 ./shadowsocks-all.sh uninstall锐速 状态 service serverSpeeder status锐速 流量速度 service serverSpeeder stats锐速 卸载 chattr -i /serverspeeder/etc/apx* &amp;&amp; /serverspeeder/bin/serverSpeeder.sh uninstall -fFinalspeed 启动 /etc/init.d/finalspeed startFinalspeed 停止 /etc/init.d/finalspeed stopFinalspeed 状态 /etc/init.d/finalspeed statusFinalspeed 卸载 bash install_fs.sh uninstall 如果遇到 锐速的状态查看 提示 “bc not found” 执行 apt-get install bc 即可。 写在后面]]></content>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux子系统图形界面]]></title>
    <url>%2F2018%2F04%2F19%2FLinux-Subsystem-Gui%2F</url>
    <content type="text"><![CDATA[搞完Windows下Linux下子系统的启用，可以用命令行进行使用但是却是一个完全没有界面的系统。这样怎么能拼过虚拟机呢对吧。所以：图形界面启动！。 Windows X Server 下载 VcXsrv https://sourceforge.net/projects/vcxsrv/files/latest/download 用迅雷下会快一些👀。 运行下载下来的 VcXsrv 安装程序，安装位置自己选，开心就好。 安装完成之后会有两个软件启动方式，选择用 XLaunch 启动，在启动界面选择 One large windows 方式，显示器编号：0，接下来一路 Next 到完成结束。然后会出现一个黑黑的界面。 Ubuntu的桌面软件安装 安装 Ubuntu 桌面软件，unity，compiz配置软件,下载的软件很大。大概需要2.5个G的空间，耐心等待(我大概用了15分钟左右才装好)。1sudo apt-get install ubuntu-desktop unity compizconfig-settings-manager Ubuntu的桌面的配置 设置显示器 ; 1export DISPLAY=localhost:0 设置桌面参数,勾选了Ubuntu Unity Plugin 和 Window Management 下的 Place Window选项，其他的根据自己需要修改。设置完毕之后关闭即可; 1ccsm 展示桌面，运行下面指令。就可以在上面说的黑黑的界面上绘出桌面了。看起来是不是毫无违和感23333。 1compiz 做一个脚本便于设置和启动桌面。新建一个脚本放在根目录 cd / &amp;&amp; sudo vi vcxsrv.sh 将下面的代码粘贴到 vcxsrv.sh 里，再赋予执行权限 chmod +x vcxsrv.sh 。每次先用控制台进入 bash 运行脚本就OK了。123#! /bin/shexport DISPLAY=localhost:0 #设置显示屏compiz 内存占用经过实测,8G内存，即使开启图形界面之后内存占用提升仅仅接近500M(31%–&gt;37%)，对比虚拟机(起码分配2G内存)少的就不止一点半点了好吧。确实是指的鼓捣的东西。 已知的一些问题 键盘的上下左右键值会被识别为数字8246，并且很鬼畜的识别为长按🤕，猜测原因：系统默认不开启数字键盘,导致识别错误但是识别为长按是什么鬼嘛。这一点很蛋疼。 刚启动桌面，桌面鼠标不可见或者会变成 × 号，解决办法：打开一个应用程序(非终端)后正常。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Linux子系统图形界面</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cmder 更好的选择]]></title>
    <url>%2F2018%2F04%2F19%2FCMD-replace-for-Cmder%2F</url>
    <content type="text"><![CDATA[就如同封面一样，Cmder 看着就令人赏心悦目。微软自带 CMD 就不谈了好吧，不过Windows本身就不是擅长用控制台和用户打交道的系统，所以这样也无可厚非吧。不过现在有了更好的选择：Cmder。Cmder安装 这是Cmder官网，Cmder你可以选择两种版本，Mini和Full 这俩的区别我也不是很清楚，看网上说的也没有什么说服力🤔。我下载Full版本(zip100M)。下载地址 下载完毕之后直接解压到你喜欢的目录下面就 OK 了(自己建一个根目录啊他自己没有外封根目录的😅)，点击软件根目录下面的’Cmder.exe’即可启动 Cmder 软件。 添加 Cmder 环境变量 操作流程：此电脑—&gt;右键—&gt;属性(控制面板\所有控制面板项\系统)—&gt;侧边栏高级系统设置—&gt;右下角环境变量； 根据你的需要，是作为本用户使用还是作为全局其他用户也能使用选择添加为用户变量还是系统变量。找到Path变量条。a. 双击，在弹出来的编辑窗口选择新建按钮，然后输入 ‘Cmder.exe’ 所在的路径；b. 如果是win7貌似是直接编辑文本的吧,那就直接在最后面添加;Cmder.exe 所在的路径 我把 Cmder 安装在 D:\cmder\ 下，结合起来就是;D:\cmder\。切记分号不能少🙂。 添加右键 Cmder Here这个是方便我们在任何文件夹直接打开 Cmder 。 用管理员身份运行系统自带的 CMD，运行命令：Cmder.exe /REGISTER ALL (没有报错)。 任意 Cmder 窗口—&gt;标题栏—&gt;右键—&gt;Settings…—&gt;Startup—&gt;Task ; 依次点击命令组下所有的命令任务在右下方的编辑框后面加-new_console (前导空格别忘了) ; 关闭设置窗口~，设置完毕。在任意目录下右键即可看到 Cmder Here 字样的菜单。 自定义终端符号这是个花里胡哨的操作😬。分为两个: powershell 和 cmd . 修改 cmd 的提示符：用文本编辑软件打开 软件根目录\vendor\clink.lua 文件， 找到大概47行左右，两句话 lambda = &quot;λ&quot; 和 lambda = &quot;(&quot;..env..&quot;) λ&quot; 替换 λ 为你喜欢的，我替换成 ღ (可以用搜狗特殊字符找一下自己喜欢的😹)。 修改 powershell 的提示符：打开 clink.lua同级目录下的profile.ps1 文件。 找到大概121行，Utility\Write-Host “`nλ “ -NoNewLine, 找到157行左右，两句话 λ &lt;PostPrompt&gt; &lt;repl input&gt; 和 λ &lt;PostPrompt&gt; 将 λ 替换为你想要的。 重启软件完成设置。 设置终端背景 任意 Cmder 窗口—&gt;标题栏—&gt;右键—&gt;Settings…—&gt;Main—&gt;Background ; 勾选使用背景图像，在路径里找一张你喜欢的背景图片设置为背景 ; 在暗化调整(Darking)选项，可以调整图片的防止掩盖终端字体显示不清楚 ; 在放置方式管理(Placement)列表里可以选择你想把图片作何种放置(我设置的伸缩铺满窗口Stretch-Fill)。你也可以通过背景插件 Far Manager 进行设置。 解决中文乱码使用默认的 cmder 中文会被识别为 \数字 的组合 根本没法看。 任意 Cmder 窗口—&gt;标题栏—&gt;右键—&gt;Settings…—&gt;Environment ; 在右侧编辑框里另起一行写入set LC_ALL=zh_CN.UTF-8 完成设置，重启 cmder 生效。、远程ssh连接服务器中文依然会乱码…。 配色主题 任意 Cmder 窗口—&gt;标题栏—&gt;右键—&gt;Settings…—&gt;Features—&gt;Colors ; 上方 Schemes 列表里选择你喜欢的配色方案~。 alias功能Cmder提供的 alias 功能可以让我们用较为简短易记的单词指令替代很长的语法指令。在终端输入指令 alias 即可查看别名对应的真正语法指令，可以通过软件根目录\config\user-aliases.cmd 写人自己需要用到的却又难记的语法指令和别名的对应式子。比如我想要去我bolg所在的目录。每次都 cd 慢慢过去很烦，我就可以用 blog =cd /d &quot;E:\GitHome\blog&quot; 添加到 user-aliases.cmd 文件里，之后再终端直接输入blog就切换到blog的目录里。登录服务器可以用这个配合putty实现Tencent=&quot;D:\Program Files\PuTTY\plink.exe&quot; 255.255.255.255 -l root -pw &quot;12346578&quot;。 后记 cmder直接支持 ctrl+c 和 ctrl+v，在终端里双击选中即已经复制不需要用ctrl+c。 支持 vim 编辑器，同样的编辑方式和语法。 其他的一些设置诸如文字大小，默认启动也可以自行了解一下。 Cmder 核心就是基于 ConEmu 做的，不过外面加了大量的Linux下的工具命令。很多Linux的命令在上面都可以运行。 cmder github地址: https://github.com/cmderdev/cmder]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>cmder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10下Linux子系统的启用]]></title>
    <url>%2F2018%2F04%2F19%2FWin10-Linux-Subsystems%2F</url>
    <content type="text"><![CDATA[微软在win10系统上添加了Linux子系统的支持，方便我们可以在windows上使用Linux，省去了占内存的虚拟机和双系统切换的麻烦😎，具体有什么和普通安装的Linux有什么不同，抱歉…不知道😬。Linux子系统的获取 在 ‘控制面板–&gt;程序和功能(侧边栏)–&gt;启用或关闭 Windows 功能–&gt;勾选适用于 Linux 的 Windows 子系统选项’。这样就成功使能 Linux 子系统的功能。（需要重启生效更新，请保存你的Word文档☠️…）我看到网上的教程说明需要选中 ‘设置–&gt;更新和安全–&gt;针对开发人员–&gt;开发人员模式’ 但我的选项是 ‘旁加载应用’ 也成功操作。 Linux子系统的获取可以用微软的应用商店进行安装。如下图是支持的子系统种类(2018.04.19)，我选择了Ubuntu 要使用其他系统的也看看，以后会支持更多的系统~ ~。 就像装其他软件一样点击安装就会自动下载了。下载挺快的还📢，安装完毕之后就会显示启动这时候系统未被写入到磁盘里的。 这样获取 Windows 下Linux子系统就完成了。点击启动会打开CMD运行然后将系统写入磁盘，所需时间并不长(SSD少于1分钟)长时间卡住尝试回车一下请求响应刷新界面。写入完毕会让你输入一个用户名(自定义哦不必须是 Windows 的用户名)和密码(不可见)。输入完毕就创建了一个用户，之后默认就是这个账户登录进系统。这个用户不具备管理员权限，如果你要默认使用管理员用户，那就直接关闭这个 CMD，就跳过这一步了。之后再打开就直接以 root 用户登录。123456789101112Installing, this may take a few minutes...Installation successful!Please create a default UNIX user account. The username does not need to match your Windows username.For more information visit: https://aka.ms/wslusersEnter new UNIX username: begildEnter new UNIX password:Retype new UNIX password:passwd: password updated successfullyDefault UNIX user set to: begildTo run a command as administrator (user "root"), use "sudo &lt;command&gt;".begild@BeGild-PC:~$ Linux 子系统的位置 Linux子系统位于（Users == 用户 👎）: C:\Users\用户名\AppData\Local\Packages\含有Linux子系统名字的文件夹\LocalState\rootfs 我使用的账户是 Administrator 装的是 Ubuntu 那么位置就是:C:\Users\Administrator\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs 其他的系统和这个差不多，在 Packages 目录下找一下含有你安装的 Linux 子系统名字的文件夹就能找到。 Linux子系统位置的迁移因为linux子系统的位置式位于C盘的文件夹下面的，时间长了的话会产生大量的数据，C盘本来就装了Windows，现在加了一个Linux，两个系统的使用会导致C盘加速被塞满。所以，把C盘迁移到其他的数据盘是一个比较好的选择。当然你的C盘足够大任性选择也OK。123robocopy "子系统所有数据所在的位置" "迁移的目的地址" /E /COPYALL /XJ rmdir "子系统所有数据所在的位置" /S /Q mklink /J "子系统所有数据所在的位置" "迁移的目的地址" 我的子系统所有数据所在的位置是C:\Users\Administrator\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc迁移的目的地址是 D:\WSL所以代码就是123robocopy "C:\Users\Administrator\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc" "D:\WSL" /E /COPYALL /XJ rmdir "C:\Users\Administrator\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc" /S /Q mklink /J "C:\Users\Administrator\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc" "D:\WSL" 如果删除子系统数据目录的步骤(rmdir) 遇到不是空目录无法删除，重启电脑之后再执行就OK了。执行上面的东西用 cmder 使用 ls 命令可以看到已经建立一个符号链接到目标目录了。这样就把东西全部迁移到 D:\WSL 里去。123C:\Users\Administrator\AppData\Local\Packagesღ ls -l CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsclrwxrwxrwx 1 Administrator 197121 6 4月 22 14:10 CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc -&gt; /d/WSL/ Linux子系统的打开 任意打开一个CMD窗口输入bash 启动一个Linux终端； 将 Ubuntu 固定到开始菜单磁贴，每次点击都能打开一个新的Linux终端窗口。 Linux子系统的一些信息 使用lsb_release -a 可以看到系统的信息安装的是16.04.3长期支持版本 cat /proc/version 可以看到内核版本 4.4.0-43-Microsoft;编译器GCC版本5.4.012345678910root@BeGild-PC:~# lsb_release -aNo LSB modules are available.Distributor ID: UbuntuDescription: Ubuntu 16.04.3 LTSRelease: 16.04Codename: xenialroot@BeGild-PC:~# uname -r4.4.0-43-Microsoftroot@BeGild-PC:~# cat /proc/versionLinux version 4.4.0-43-Microsoft (Microsoft@Microsoft.com) (gcc version 5.4.0 (GCC) ) #1-Microsoft Wed Dec 31 14:42:53 PST 2014 换软件源emmm,将软件源换为国内源，这样更新和下载软件都会比较快一点。 备份软件源列表： 1# mv /etc/apt/sources.list /etc/apt/sources.list.bak 编辑软件源。 1# vi /etc/apt/sources.list 替换为国内源(我选清华大学源,可以去看看阿里源什么的)。 12345678910111213# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse 更新软件列表 1# apt-get update 更新软件,第一次会下载比较多的更新耐心等待。 1# apt-get upgrade]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Win10下linux子系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32 Flash的读写]]></title>
    <url>%2F2018%2F03%2F07%2FSTM32-Flash-Write-Read%2F</url>
    <content type="text"><![CDATA[这里记一下STM32F4板子FLASH的读写操作以及需要注意的地方。 FLASH的写操作 FLASH由 ‘1’ 变为 ‘0’ 不能由 ‘0’ 变为 ‘1’ ，所以在写入之间需要检测是否为 ‘1’ ,并且擦除flash只能按照一个扇区来删除，由上可知，我们写入之前必须确保我们需要写入的地址读回来的值是0XFF，如果不是0XFF就需要将整个扇区擦除(扇区变为全 ‘1’ )。 写入操作(包括擦除)之前需要将FLASH解锁 FLASH_Unlock()，操作完成之后需要将FLASH上锁 FLASH_Lock() 。 正点原子的例子 写入流程: 解锁FLASH FLASH_Unlock()； 禁止数据缓存FLASH_DataCacheCmd(DISABLE),根据你传入的起始地址 WriteAddr 和写入的字节数 NumToWrite 计算出结束地址 endaddr； 遍历整个写入范围，一旦发现非 ’1‘ 数据的出现就擦除整个扇区，他这里是字(Word)来检测的，所以地址 addrx 每次加4； 检测完毕并且擦除之后，进入写操作，每次写入一个字(4byte)的数据。所以 WriteAddr 每次加4, u32 *pBuffer 每次加1 ； 使能数据缓存FLASH_DataCacheCmd(ENABLE)，上锁FLASH FLASH_Lock()。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//从指定地址开始写入指定长度的数据//特别注意:因为STM32F4的扇区实在太大,没办法本地保存扇区数据,所以本函数// 写地址如果非0XFF,那么会先擦除整个扇区且不保存扇区数据.所以// 写非0XFF的地址,将导致整个扇区数据丢失.建议写之前确保扇区里// 没有重要数据,最好是整个扇区先擦除了,然后慢慢往后写.//该函数对OTP区域也有效!可以用来写OTP区!//OTP区域地址范围:0X1FFF7800~0X1FFF7A0F//WriteAddr:起始地址(此地址必须为4的倍数!!)//pBuffer:数据指针//NumToWrite:字(32位)数(就是要写入的32位数据的个数.)void STMFLASH_Write(u32 WriteAddr, u32 *pBuffer, u32 NumToWrite)&#123; FLASH_Status status = FLASH_COMPLETE; u32 addrx = 0; u32 endaddr = 0; if(WriteAddr &lt; STM32_FLASH_BASE || WriteAddr % 4)return; //非法地址 FLASH_Unlock(); //解锁 FLASH_DataCacheCmd(DISABLE);//FLASH擦除期间,必须禁止数据缓存 addrx = WriteAddr; //写入的起始地址 endaddr = WriteAddr + NumToWrite * 4; //写入的结束地址 if(addrx &lt; 0X1FFF0000) //只有主存储区,才需要执行擦除操作!! &#123; while(addrx &lt; endaddr) //扫清一切障碍.(对非FFFFFFFF的地方,先擦除) &#123; if(STMFLASH_ReadWord(addrx) != 0XFFFFFFFF) //有非0XFFFFFFFF的地方,要擦除这个扇区 &#123; status = FLASH_EraseSector(STMFLASH_GetFlashSector(addrx), VoltageRange_3); //VCC=2.7~3.6V之间!! if(status != FLASH_COMPLETE)break; //发生错误了 &#125; else addrx += 4; &#125; &#125; if(status == FLASH_COMPLETE) &#123; while(WriteAddr &lt; endaddr) //写数据 &#123; if(FLASH_ProgramWord(WriteAddr, *pBuffer) != FLASH_COMPLETE) //写入数据 &#123; break; //写入异常 &#125; WriteAddr += 4; pBuffer++; &#125; &#125; FLASH_DataCacheCmd(ENABLE); //FLASH擦除结束,开启数据缓存 FLASH_Lock();//上锁&#125; 测试和分析经过实验，擦除扇区的时间是很久的，擦除128KByte的扇区大概需要1s多。并且，不解锁虽然可以通过擦除函数并且返回 FLASH_COMPLETE 但是实际并没有擦除成功。我开始以为他这个耗时主要体现在读和判断，擦除操作比较快，😒但其实读120KByte的数据只需要3.9ms加上判断的时间也没多少主要的时间耗费在擦除操作上。😆另一个体现就是如果在 Keil 的工程选项里把擦除全部flash勾选，下载前的擦除的时间是很长的。下面是测试代码和解释结果。测试结果可以看出，擦除的时间并没有很大变化，因为都是需要一次性操作一个扇区，只要不超过一个扇区的长度都不会变化很大。写入和读出的时间保持线性变化。所有的测试都是用原子官方例程按照WORD(32bit)来写入的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int main(void)&#123;...上续代码 STMFLASH_Write(FLASH_SAVE_ADDR, (u32 *)&amp;txbuf, SIZE);//写入一些数据保证flash不全为'1' uprintf(USART1, "扇区预先不为全 '1'时写入:\r\n"); uprintf(USART1, "写入长度:%d\r\n", TEXT_LENTH); //原子的例子擦除flash再写入数据 STMFLASH_Write(FLASH_SAVE_ADDR, (u32 *)&amp;txbuf, SIZE); memset(readbuf,0,TEXT_LENTH);//清空数据读取 StartTiming(); STMFLASH_Read(FLASH_SAVE_ADDR, (u32 *)&amp;readbuf, SIZE); timems = GetTimeMs(); uprintf(USART1, "读出耗时:%.3fms\r\n", timems); uprintf(USART1, "读出长度:%d\r\n----\r\n", TEXT_LENTH, strlen((const char *)readbuf));...下续代码&#125;void STMFLASH_Write(u32 WriteAddr, u32 *pBuffer, u32 NumToWrite)&#123;...上续代码 FLASH_DataCacheCmd(DISABLE);//FLASH擦除期间,必须禁止数据缓存 StartTiming();//开始计时擦除扇区耗时.....上续代码 timems = GetTimeMs(); uprintf(USART1,"擦除扇区耗时 :%.3fms\r\n",timems); StartTiming();//开始写入计时 if(status == FLASH_COMPLETE) &#123;...上续代码 FLASH_Lock();//上锁 timems = GetTimeMs();//获取写入耗时 uprintf(USART1, "写入耗时:%.3fms\r\n", timems);&#125;/*测试结果 测试120、12K、120K(Byte)的数据*/扇区预先不为全 '1'时写入:写入长度:120擦除扇区耗时 :1046.720ms写入耗时:0.440ms读出耗时:0.020ms读出长度:120 ----扇区预先不为全 '1'时写入:写入长度:12288擦除扇区耗时 :1050.220ms写入耗时:45.700ms读出耗时:0.380ms读出长度:12288 ----扇区预先不为全 '1'时写入:写入长度:122880擦除扇区耗时 :1051.860ms写入耗时:458.700ms读出耗时:3.880ms读出长度:122880 ---- 改进擦除方式 改进的一点想法根据正点原子的测试结果来看，擦除扇区的时间是不可避免的，无非就是暴力一点不检测直接擦除(因为通常来说，如果你存储在固定的flash地址除了第一次之后都会有数据)。这样搞了之后从测试的结果来看提升并不明显。写120KByte的数据下擦除时间少了4ms左右😔(少了读取和判断的时间)。所以擦除的方式并没有很好的改进方法(标题党😈)。 通用性考虑 通过正点原子的例子熟悉了Flash的读写，但是只支持4字节对齐(WORD)的操作,我看了一下库的函数是可以支持 BYTE，HALFWORD,WORD, 和 DOUBLEWORD 的，不过 DOUBLEWORD 需要外部Vpp。所以想改进一些支持库函数里的各种byte(1-4) 的操作。 修改好之后测试一下测试代码和上面原版的差不多。只是写入函数换成了修改之后的STMFLASH_WriteWithErase，测试结果如下,测试的时候用的是WORD方式写入。和原子基本没有差别。123456789101112131415161718192021扇区预先不为全 '1'时写入:写入长度:120擦除扇区耗时 :1043.500ms写入耗时:0.460ms读出耗时:0.000ms读出长度:120 ----扇区预先不为全 '1'时写入:写入长度:12288擦除扇区耗时 :1046.580ms写入耗时:45.700ms读出耗时:0.400ms读出长度:12288 ----扇区预先不为全 '1'时写入:写入长度:122880擦除扇区耗时 :1050.860ms写入耗时:459.140ms读出耗时:3.900ms读出长度:122880 ---- 其他ByteSize方式写入相对于用WORD来说用其他方式写入flash是要慢一些的。采用 BYTE 方式需要 大概1832ms,采用HALFWORD方式需要920ms左右。因为擦除都是采用的VoltageRange_3也就是WORD方式所以擦除时间差不多。 分离操作的方式 分离操作的意义把擦除和写入分开。考虑到一个扇区是非常大的，一个扇区可能会存储多种数据。如果写入之前有数据就会导致整个扇区被擦除，数据就会丢失。所以采用分离的办法，把数据的写入和擦除分隔开，根据需要选择是否擦除扇区内的数据，保证在擦除的操作之前有相应的备份操作就OK了。这样即使忘记擦除那么也只是新的数据没法正确写到flash里面，其他部分的数据就不会被擦除，这样有利于更好的数据完整性。 测试结果和测试代码,经过测试分离之后的操作和没分离的时间上基本没什么差别，12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849分离操作方式写入flash:擦除扇区耗时:1023.320ms写入长度:120 byte写入耗时:0.440ms读出耗时:0.000ms读出长度:120 byte****分离操作方式写入flash:擦除扇区耗时:1015.140ms写入长度:12288 byte写入耗时:45.940ms读出耗时:0.400ms读出长度:12288 byte****合并操作方式写入flash:写入长度:122880擦除扇区耗时 :1010.480ms写入耗时:461.420ms读出耗时:3.900ms读出长度:122880 ****int main（void）&#123;...上续代码 uprintf(USART1, "分离操作方式写入flash:\r\n"); StartTiming(); status = StmEraseFlashSector(FLASH_SAVE_ADDR, TEXT_LENTH); //FLASH_DataCacheCmd(DISABLE);//FLASH擦除期间,必须禁止数据缓存 //status = FLASH_EraseSector(STMFLASH_GetFlashSector(FLASH_SAVE_ADDR), VoltageRange_3); //VCC=2.7~3.6V之间!! if(status != FLASH_COMPLETE) &#123; uprintf(USART1, "擦除扇区失败:%d\r\n",status); //发生错误了 while(1) &#123;&#125;; &#125; timems = GetTimeMs(); uprintf(USART1, "擦除扇区耗时:%.3fms\r\n", timems); uprintf(USART1, "写入长度:%d byte\r\n", TEXT_LENTH); StartTiming(); //不需要擦除falsh直接写数据 STMFLASH_WriteNoErase(FLASH_SAVE_ADDR, txbuf,TEXT_LENTH,ByteSize); timems = GetTimeMs(); uprintf(USART1, "写入耗时:%.3fms\r\n", timems); memset(readbuf,0,TEXT_LENTH);//清空数据读取 StartTiming(); STMFLASH_Read(FLASH_SAVE_ADDR,readbuf, TEXT_LENTH,ByteSize); timems = GetTimeMs(); uprintf(USART1, "读出耗时:%.3fms\r\n", timems); uprintf(USART1, "读出长度:%d byte\r\n****\r\n", TEXT_LENTH, strlen((const char *)readbuf)); &#125; 后记搞了几天才把这个写完整。中途也进了好多的坑，浪费了好长时间。不过还是写完了。说一点注意的地方 flash的写入地址不是偶数就可以，得是4的倍数。 无论是擦除还是写入都需要先解锁flash。读取则不需要。 对于同一个扇区的建议用分离的操作，并且在操作前根据需要把其他的数据读出来备份一下在写进去。 关于本文的代码详见于Coding项目。]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>Flash读写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32自定义串口printf]]></title>
    <url>%2F2018%2F03%2F01%2FSTM32-UART-CustomPrintf%2F</url>
    <content type="text"><![CDATA[前言硬件的调试通常可分为两大类，一种是用调试器将芯片和电脑连接通过单步等方式逐步运行进行调试，另一种就是printf大法在程序运行过程中输出调试信息。第一种比较深入，可以了解每一个变量，栈堆，函数等等的变化是比较系统化的调试。但我通常都是用printf来调试的，因为快速简单属于非介入的方式，调试完毕直接注释掉相关部分就行了。 重定向 printf 函数对于STM32来说现在串口例程一般都配有一个printf重定向到串口1的代码，直接可以使用printf很方便的输出信息到串口上。1234567//重定义fputc函数int fputc(int ch, FILE *f)&#123; while((USART1-&gt;SR&amp;0X40)==0);//循环发送,直到发送完毕 USART1-&gt;DR = (u8) ch; return ch;&#125; 自定义printf函数但是我们如果使用多个串口或者说串口输出不一定总从串口1输出怎么办呢。这时候这样就没法实现，后来上网查一下我们可以自己实现printf这个函数。命名为uprintf，接收至少两个参数，第1个参数是串口号;第2个是格式化字符串;第3-n ‘ … ‘ 是参数匹配列表， 实现变长的参数列表接收。。1234567891011//用串口写一个printf函数void uprintf(USART_TypeDef *USARTx, const char *fmt, ...)&#123; va_list ap; //typedef char *va_list; va_list是char型的指针 char *s_string = malloc(300); //申请缓冲区 va_start(ap, fmt); //找第一个可变形参的地址，并把地址赋给ap vsprintf(s_string, fmt, ap); //类似sprintf函数 USART_String(USARTx, s_string); //发送和整个字符串 va_end(ap); //结束 free(s_string);&#125; 上面这个函数里的过程: 通过 va_start 函数获得参数列表里每个项和格式化字符里对应的位置，形成一个列表 ap 。 通过 vsprintf 把列表里每个参数转为字符串写到 s_string 字符串里。 通过 USART_String 发送到串口。 释放列表 ap 和 发送缓冲 s_string 。 完整的一个自定义printf实现文件1234567891011121314151617181920212223242526272829#include "uart_x.h"#include "stdlib.h"#include "stdarg.h"//发送一个字节void SendByte(USART_TypeDef *USARTx, unsigned char dat)&#123; while((USARTx-&gt;SR &amp; 0X40) == 0) &#123;&#125;; //循环发送,直到发送完毕 USARTx-&gt;DR = (u8) dat;&#125;//发送一个字符串void USART_String(USART_TypeDef *USARTx, char *s)&#123; while(*s != '\0') // '\0' 表示字符串结束标志 &#123; SendByte(USARTx, *s); s++; &#125;&#125;//用串口写一个printf函数void uprintf(USART_TypeDef *USARTx, const char *fmt, ...)&#123; va_list ap; //typedef char *va_list; va_list是char型的指针 char *s_string = malloc(300); //申请空间 va_start(ap, fmt); /找第一个可变形参的地址，并把地址赋给ap vsprintf(s_string, fmt, ap); //类似sprintf函数 USART_String(USARTx, s_string); //发送和整个字符串 va_end(ap); //结束 free(s_string);&#125; 上面的函数已经能满足多个串口同时使用printf，根据自己的需求可以修改申请的缓冲区大小即可。 安全版本的自定义 printf 实现但上面的实现并不是安全的，如果你发送的字符串长度大于缓冲区长度就会造成内存溢出。所以你可以更改为一个安全的版本，接收一个缓冲区长度参数从而申请一个合适大小的空间。1234567891011//用串口写一个printf函数void uprintf_s(USART_TypeDef *USARTx, uint32_t BuffSize,const char *fmt, ...)&#123; va_list ap; //typedef char *va_list; va_list是char型的指针 char *s_string = malloc(BuffSize); //申请空间 va_start(ap, fmt); //找第一个可变形参的地址，并把地址赋给ap vsprintf_s(s_string,BuffSize, fmt, ap); //类似sprintf_s函数 USART_String(USARTx, s_string); //发送和整个字符串 va_end(ap); //结束 free(s_string);&#125; 后记 使用 printf 大法非常方便，但是尽量避免在中断里调用该函数(执行 printf 需要的时间比较久),以及调试完毕之后注释掉相关的代码，缩短功能代码的执行时间。 有兴趣的可以写 printf 到 OLED 之类的函数，原理都是一样，实现屏幕位置控制和最后的写一个字节的函数就能完成移植。]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>串口(UART)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SMT32串口接收、空闲中断]]></title>
    <url>%2F2018%2F03%2F01%2FSTM32-UART-IDLE-IT-md%2F</url>
    <content type="text"><![CDATA[识别尾进行接收结束的验证 串口接收完毕标志可以利用识别特定字符(字符串)来检测，比如 “\r\n”、’*#’ 之类的。所以每次发数据都需要加上这些字符才能被识别为接收完毕，这样好处就是比较通用。无论是什么硬件平台都能用。代码也不复杂，在STM32平台上简单的例子如下代码段：当接收到 ‘*‘ 时候就会置位接收完成标志位，就可以进行处理了。123456789101112131415161718#define MAXUSART1BUFSIZE 200uint8_t Uart1_BUF[MAXUSART1BUFSIZE];void USART1_IRQHandler(void) //串口1中断服务程序 &#123; uint8_t RecByte; static uint32_t pos = 0; if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) &#123; RecByte = USART1-&gt;DR;//读取接收到的数据 if(pos &lt; MAXUSART1BUFSIZE)//防止内存溢出 Uart1_BUF[pos++] = RecByte; if(RecByte == '*') &#123; //TODO: 接收完毕相关处理 pos = 0; &#125; &#125;&#125; 识别头尾进行数据段的保护 上面的方法就是发送的时候麻烦一点，每次都需要在后面加 ‘*‘, 并且如果发送错一次(忘记加 ‘*’)就会把缓冲区的内容累计到下一次(可以添加头识别进行解决)。这样就只会识别指定的数据段。一般这样适用于发送带有意义的控制数据保证数据不多收也不少收。验证的字符要保证不会出现在内容里，或者用多个字符进行验证。12345678910111213141516171819202122232425#define MAXUSART1BUFSIZE 200uint8_t Uart1_BUF[MAXUSART1BUFSIZE];void USART1_IRQHandler(void) //串口1中断服务程序&#123; uint8_t RecByte; static uint32_t pos = 0; if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) //接收中断(接收到的数据必须是0x0d 0x0a结尾) &#123; RecByte = USART1-&gt;DR;//读取接收到的数据 if(RecByte == '#') pos = 1; //开始接收数据 if(pos) &#123; if(pos &lt; MAXUSART1BUFSIZE)//防止内存溢出 Uart1_BUF[pos - 1] = RecByte; pos ++; if(RecByte == '*') &#123; //TODO: 接收完毕相关处理 pos = 0; &#125; &#125; &#125;&#125; STM32空闲中断的配置 前几天做项目也要用到串口传输控制信息在STM32上的话可以利用串口空闲中断(接收完字符以后在下一个传输字符的时间内没有字符传来)来接收数据，这样就不用像上面那样做特定的识别，也比较方便。在这里备注一下，因为当时一开始配置完了并不起作用，后来上网查证了最后才找到解决办法。初始化的代码就不贴了，主要是最后配置完毕，开中断的代码贴一下。 123456...上续初始化的相关配置USART_Init(USART1, &amp;USART_InitStructure); //初始化串口USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启中断USART_ITConfig(USART1, USART_IT_IDLE,ENABLE);//开启中断//USART_ClearITPendingBit(USART1, USART_IT_IDLE |USART_IT_RXNE);//清除中断USART_Cmd(USART1, ENABLE); //使能串口 一开始我使用的是下面这条语句进行中断配置的，发现并不能触发空闲中断，后来才知道必须要分两次才能正确配置: 1USART_ITConfig(USART1, USART_IT_RXNE | USART_IT_IDLE, ENABLE);//开启中断 查看了一下USART_ITConfig()函数的源码才看出来，他这个函数为了USART_IT_IDLE等中断宏定义的通用性，必须每次只能初始化一个中断标志。 12345678910111213141516void USART_ITConfig(USART_TypeDef *USARTx, uint16_t USART_IT, FunctionalState NewState)&#123;.... /* Get the interrupt position */ itpos = USART_IT &amp; IT_Mask; itmask = (((uint32_t)0x01) &lt;&lt; itpos);....&#125;/*相关计算#define USART_IT_IDLE ((uint16_t)0x0424)#define IT_Mask ((uint16_t)0x001F) //!&lt; USART Interrupt Mask itpos = 0x0424 &amp; 0x001F = 0x04;itmask = (((uint32_t)0x01) &lt;&lt; itpos) = 0x10;0x10 = 0b00010000//bit[4];查阅官方的手册可以看到空闲中断使能也恰好就是bit[4];*/ 究其原因是因为itmask这个变量其实就是中断位于寄存器的位置，他是一个0bxx1xx的变量。只能表示一个中断标志位所以每次只能初始化一个标志位。 STM32空闲中断服务函数 接下来就是中断服务函数了： 123456789101112131415161718192021uint8_t USART1RecBuf[USART1RecBufMaxSize];//接收缓冲区uint8_t sdfsdf = 0;void USART1_IRQHandler(void) //串口1中断服务程序&#123; static uint16_t pos = 0; if(USART_GetITStatus(USART1, USART_IT_IDLE) != RESET) //接收完毕触发空闲中断 &#123; pos = 0; USART1-&gt;DR;//清除空闲中断标志位 //TODO: 中断接收完成标志 &#125; if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) &#123; uint8_t RecByte; Res = USART1-&gt;DR; //读取接收到的数据 if(pos &gt;= USART1RecBufMaxSize) //超过范围返回 return ; USART1RecBuf[pos++] = RecByte; &#125;&#125; 这里需要注意的就是空闲中断的清除并不是调用USART_ClearITPendingBit()函数来清除,查看库的函数源码实现也可以看到注释里并没有说明 USART_IT_IDLE 该参数是可以被传入的，并且我们使用 USART1-&gt;DR 就能清除串口空闲中断。 12345678910111213/**... * @param USART_IT: specifies the interrupt pending bit to clear. * This parameter can be one of the following values: * @arg USART_IT_CTS: CTS change interrupt (not available for UART4 and UART5) * @arg USART_IT_LBD: LIN Break detection interrupt * @arg USART_IT_TC: Transmission complete interrupt. * @arg USART_IT_RXNE: Receive Data register not empty interrupt.... */void USART_ClearITPendingBit(USART_TypeDef *USARTx, uint16_t USART_IT)&#123;···· 到此完成了串口空闲中断的配置，之后只要两次接收数据之间的时间大于一个字符的时间(跟波特率有关),就能触发这个中断。]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>串口(UART)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ESP8266工程的裁剪和编译]]></title>
    <url>%2F2018%2F01%2F23%2FESP8266%E5%B7%A5%E7%A8%8B%E7%9A%84%E8%A3%81%E5%89%AA%E5%92%8C%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[前言本篇文章主要讲一下，乐鑫官方给的ESP8266 Demo怎么裁剪成我们要的样子以及编译。 模板工程所需文件由于官方给的工程是包含了全部的Demo和库所以我们直接使用是不能编译的。我们就从一个最基础的工程模板开始裁剪，因为其他的功能都可以通过工程模板添加库和代码来实现。首先亮一下官方原版的RTOS SDK的工程结构(下左图)。 我们需要把这个工程做成一个最基本的模板那么就需要把里面冲突的和暂时不需的都给删除。如下图是需要裁剪的内容： 红色的是需要删除的。紫色的删了节省空间。所以我们把刚刚标记这些都全部删除(别忘了备份一个原版的以后用)之后，这样就会少了很多东西。那现在可以编译了吗？打扰了，并不行。因为makefile这个神奇的东西存在，所以我们需要做一些调整和更改使得makefile能正确的识别、编译、链接整个工程。至于makefile是什么东西大家上网搜查看！这里就不展开讲了，因为就那个就可以做一个专题23333。你暂时只需要知道编译整个工程需要它掌控整个工程的各个文件的信息和关系的，所以我们需要告诉它各个文件的信息和之间的关系，所幸的是官方给的makefile已经很通用了，我们稍微做改变就可以了(感谢ing…) 模板工程文件的调整下面的操作就是属于比较灵性的，不要问我为什么因为我个人觉得这样比较好。先按照我的来，等你学会了就可以去装逼了。先约定”/“就是工程的根目录，用绝对路径目录有点长。 剪切 /driver_lib/driver —&gt; /examples/project_template/ 剪切 /driver_lib/include/ 的所有头文件 —&gt; /examples/project_template/include/ 改名 /examples/project_template —&gt; app 复制 /examples/app —&gt; / 删除 /app/sample_lib 目录 删除 /driver_lib 目录 删除 /examples 目录 这样就完成了工程文件的调整：把相关的硬件驱动移到app目录下面，并且删除了示例的库。调整完成之后的目录如下图(documents目录删不删不影响)： MakeFile文件的修改 修改/Makefile文件 文件里添加两句话SDK_PATH=××× BIN_PATH=xxx 比如我的工程根目录在 “ e:/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template “那么我的文件修改如下：12345678910....ifndef PDIRendifSDK_PATH=e:/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_templateBIN_PATH=e:/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/bin ifeq ($(COMPILE), xcc)... 2.修改/app/Makefile文件 文件里添加一句话SDK_PATH=××× 添加在文件的17行左右，内容就是你工程的根目录。 文件里的SUBDIR=××× 把所有包含了c文件的子目录都添加进去。(‘\’表示续一行)，ctrl+f可快速查找，修改位置大概在23行左右。 修改完成之后如下： 123456789101112131415...上续#FLAVOR = releaseFLAVOR = debugSDK_PATH=e:/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template#EXTRA_CCFLAGS += -uifndef PDIR # &#123;GEN_IMAGES= eagle.app.v6.outGEN_BINS= eagle.app.v6.binSPECIAL_MKTARGETS=$(APP_MKTARGETS)SUBDIRS= \ user \ driverendif # &#125; PDIR...下续 把COMPONENTS_eagle.app.v6=××× 需要的.a文件修改为子目录下生成对应的.a文件(听不懂没关系，看效果代码)，大概在48行左右。 123456789101112...上续ifeq ($(FLAVOR),release)TARGET_LDFLAGS += -g -O0endifCOMPONENTS_eagle.app.v6 = \ user/libuser.a \ driver/libdriver.a LINKFLAGS_eagle.app.v6 = \ -L$(SDK_PATH)/lib \ -Wl,--gc-sections \...下续 这样就修改完成了。 工程的编译 左键点击工程名选中工程-&gt;右键弹出菜单-&gt;BuildProject 即可编译。如果出现BuildProject选项灰色就是你没选中。如果失败可以尝试CleanProject(就在BuildProject下面)一下工程再编译。 编译之后输出窗口大致如下，输出两个bin文件：eagle.flash.bin 和 eagle.irom0text.bin ,这样就完成了工程的编译。这个固件是不支持OTA升级的，所以也不需要boot。也没有user1.bin和user2.bin。所以不要觉得奇怪。123456789101112131415161718192023:48:32 **** Incremental Build of configuration Default for project ESP8266_RTOS_SDK-1.5-project_template ****make all make[1]: Entering directory &apos;/cygdrive/e/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/app&apos;make[2]: Entering directory &apos;/cygdrive/e/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/app/user&apos;make[2]: Leaving directory &apos;/cygdrive/e/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/app/user&apos;make[2]: Entering directory &apos;/cygdrive/e/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/app/driver&apos;make[2]: Leaving directory &apos;/cygdrive/e/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/app/driver&apos;!!!SDK_PATH: e:/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_templateBIN_PATH: e:/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/binNo boot needed.Generate eagle.flash.bin and eagle.irom0text.bin successully in BIN_PATHeagle.flash.bin--------&gt;0x00000eagle.irom0text.bin----&gt;0x20000!!!make[1]: Leaving directory &apos;/cygdrive/e/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/app&apos;23:48:37 Build Finished (took 4s.472ms) 后记这篇说的可能看起来有点云里雾里。因为和平时大家用的的不需要自己编写编译规则的IDE不同。像keil的话你添加的头文件也需要的手动添加到工程的IncludePath里面去。但是用这个eclipse开发esp8266完全使用makefile控制的，你的目录，头文件，c文件都是需要你手动配置makefile的，道理都一样都是要告诉编译器怎么去编译链接文件。不过是你自己找到makefile添加而已。之后会专门有一篇大概说一下整个工程如果我们想添加新的功能文件夹(比如实现一个tcp客户端功能)，我们怎么去修改makefile。有什么疑问欢迎联系我。]]></content>
      <categories>
        <category>ESP8266</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ESP8266工程的导入]]></title>
    <url>%2F2018%2F01%2F22%2FESP8266%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%AF%BC%E5%85%A5%2F</url>
    <content type="text"><![CDATA[前言：本篇文章主要讲一下，ESP8266的工程怎么导入到Eclipse里。 准备一个SDK工程 既然是导入那么你首先得有一个现有的工程(不存在建工程的，这辈子都不可能徒手建工程的)，工程从网上找一个就OK了。 ESP8266的SDK有两种，一种是无系统(NON-OS SDK)，另一种是运行了FreeRTOS的(RTOS SDK)。 SDK类型描述优缺点NOn-OS SDK1.主要使⽤定时器和回调函数的⽅式实现各个功能事件的嵌套，达到特定条件下触发特定功能函数的⽬的。2.使⽤ espconn 接⼝实现⽹络操作，⽤户需要按照 espconn 接⼝的使⽤规则进⾏软件开发.1.无系统，顺序执行好理解占用资源少，但是不能有while(1);2.不能有超过10ms的阻塞(延时)发生，否则将会重启。RTOS SDK1.用户可以使⽤FreeRTOS 的标准接⼝实现资源管理、循环操作、任务内延时、任务间信息传递和同步等⾯向任务流程的设计⽅式;2.⽹络操作接⼝是标准 lwIP API，同时提供了 BSD Socket API 接⼝的封装实现，⽤户可以直接按照 Socket API 的使⽤⽅式来开发软件应⽤，也可以直接编译运⾏其他平台的标准 Socket 应⽤; 3.引⼊了 cJSON 库，使⽤该库函数可以更加⽅便的实现对 JSON 数据包的解析;4.兼容 non-OS SDK 中的 Wi-Fi 接⼝、SmartConfig 接⼝、Sniffer 相关接⼝、系统接⼝、定时器接⼝、FOTA 接⼝和外围驱动接⼝，不⽀持 AT 实现。1.有系统，通过任务的调度完成系统的运行，可以有延时。2.但是资源占用较多。 例子可以从乐鑫官方的下载地址下载.在下图所在的网页上面有选项选择ESP8266EX之后可以从下图所示的界面选择你所需要的SDK。 点击右边的下载按钮会跳转到GitHub(需要你懂一点点的git的知识才能下载)。如果实在没办法的话(求求你学一点git吧)，我把我写文章的时候的最新的上传到网盘，大家可以去下载 链接: https://pan.baidu.com/s/1c39VpXQ 密码: dup8 。 下载下来解压到你想放置的目录，不要有中文和(空格?)，这样工程就完成了初步的布置。接下来就是重头戏了。导入工程 第一步:应该能想到吧，那就是打开Eclipe_IDE(不会打开就算了你不适合用电脑)。 第二步:打开eclipse之后会出现欢迎界面:”Welcome to the Eclipse IDE for C/C++ Developers”。 第三步:点击 工具栏-&gt;File-&gt;Import (如图)进入导入工程窗口。 第四步:在select窗口选择C/C++-&gt;Existing Code as Makefile Project-&gt;点击Next进行下一步 第五步:Import Existing Code 窗口选择浏览你的工程路径(就是解压出来的文件的路径)-&gt;下方选择 Cygwin GCC 工具-&gt;再点击Finish按钮完成导入。如果在这一步发现没有Cygwin GCC选项回头去检查是否用Eclipse_IDE.exe选择了正确的 Cygwin 路径。 第六步:这时候你会发现，什么都没出现！怎么办？，那就是把欢迎界面叉掉！这样在右边Project栏就能发现一个折叠的工程，点击可以展开，整个界面大致如下图。我的因为是用git直接克隆下来的，所以在工程名旁边会提示橙色的字。如果你是从百度云下载的那就没有，这个无需理会，都一样(牛逼吧，git)。这时候问题输出窗口应该是什么都没有的，如果提示什么找不到g++、make等等，返回去检查是否选择的工具是Cygwin GCC！！！。后记我们都是用别人的工程(Demo)上开发的，所以这一步属于比较基础的，我们导入进来之后应该是编译通不过的！为什么，因为我们的SDK路径和写Demo的人不一样。这个涉及到makefile的编写了，不过别人已经把整个makefile编写的比较”智能”了，我们只是想要编译成功的话其实是不需要懂makefile的。我们改一改SDK的路径就行了。这个下一节再讲。 附录乐鑫官方的快速上手指导文档在上一篇-&gt;后记 里有网盘链接在这里就不放了。里面有SDK文件目录的讲解7/31页，看一下便于后面理解。 我整理了一下： RTOS SDK工程目录讲解 bin：编译⽣成的 BIN 文件，可直接下载到 Flash 中。 documents：SDK 相关的⽂档(RTOS api)或链接。 driver_lib：乐鑫官方提供的驱动示例代码。(IIC SPI GPIO等) examples：可供用户二次开发的示例代码。(我们把不要的删掉) openssl_demo：乐鑫官方提供的 OpenSSL 接口功能示例代码。 project_template：乐鑫官方提供的工程模板示例代码。(我们用这个，其他的以后再说) smart_config：乐鑫官⽅提供的 SmartConfig 功能示例代码。 spiffs_test：乐鑫官方提供的 SPIFFS 文件系统功能示例代码。 websocket_demo：乐鑫官方提供的 WebSocket 功能示例代码。 include：SDK 自带头文件，包含了用户可使⽤的相关 API 函数及其他宏定义，用户无需修改。 ld：链接时所需的脚本文件，如⽆特殊需求，用户无需修改。(根据这个可以生成多钟bin文件) lib：SDK 提供的库文件。(只能用api不能改不能看) third_party：乐鑫开放源代码的第三方库，当前包含FreeRTOS、JSON、LWIP,mbedTLS、noPoll、OpenSSL、SPIFFS 和 SSL。 tools：编译 BIN 文件所需的工程具，用户无需修改。 Non-OS SDK工程目录讲解 bin：编译⽣成的 BIN 文件，可直接下载到 Flash 中。 documents：SDK 相关的⽂档或链接。 driver_lib：外设驱动的库文件，如：UART、I2C 和 GPIO 等。 examples：可供用户次开发的示例代码，如 IoT Demo 等。 include：SDK ⾃带头文件，包含了用户可使用的相关 API 函数及其他宏定义，用户无需修改。 ld：链接时所需的脚本文件，若无特殊需求，用户⽆需修改。 lib：SDK 提供的库文件。 tools：编译 BIN 文件所需的工具，用户无需修改。]]></content>
      <categories>
        <category>ESP8266</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ESP8266开发环境的搭建]]></title>
    <url>%2F2018%2F01%2F21%2FESP8266%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[前言：本篇文章主要讲一下，ESP8266的开发环境怎么搭建。 开发工具下载:对于ESP8266的开发工具我们采用的是eclipse搭建的一个IDE。这是安信可公司开发出来的，他们公司还出了一款付费的，只需要点一点就能生成基础代码的工具(不付费只能生成代码不能编译)。点击这里下载最新的IDE。这里最新更新是2016年，应该已经停止了更新。防止链接失效，我转存到我的网盘：ESP8266开发环境 密码: qnkh。如果我的失效了请联系我更换。 开发环境搭建步骤当你忍受了百度云限速下载完成后恭喜你最艰难的一步完成！下载之后的会有四个文件：文件 |说明— |—cygwin.exe | cygwin和xtensa编译器环境Eclipse.exe | eclipse c/c++ 开发工具打包ESP_IDE.exe | 一体化开发环境(配置)工具下载前读我！！！.txt|就是说明文档和教程(我的教程意义何在!!!) 我们要把下载的文件放到你想要放的位置该位置必须不能有空格(cygwin目录不能有空格)，我一开始放在了放在了”D:\Program Files\ESP8266IDE\” 目录下导致后面没法选择 cygwin。最后我选择放在 “D:\ESP8266IDE\”， 点击打开cygwin.exe和Eclipse.exe进行自解压到当前目录，解压完成之后会在生成两个目录，”cygwin 和 eclipse”。 点击ESP_IDE.exe运行，选择cygwin目录和eclipse目录。同时右下角的Not Ask也勾选，这样下次就不会再次弹出来让你选择path。如果出问题了删除ESP_IDE.exe同级目录-&gt;config-&gt;cfg.xml，再次打开就会提示你选择。 首次运行会提示选择工作空间的路径。自己建一个目录选择就OK了,我选择”D:\ESP8266IDE\workspaces”,勾选下面的选项下次就不会弹出来让你选了。(备注：一个工作空间可以同时打开很多个工程，不是每一个工程都需要打开一次IDE)。 完成搭建这样就完成了开发环境的配置了，是不是感觉有点简单的过分。把cygwin.exe、Eclipse.exe删除节省空间。最后，别忘了把ESP_IDE.exe创建一个快捷方式到桌面(不懂的…)，这样你下次直接点击就能打开eclipseIDE了。 后记 还有另外一种使用ubuntu镜像进行编译的方式，不过没有这种方便所以就不介绍了(官方有一个文档可自行去乐鑫下载也可下载我上传到网盘的链接:https://pan.baidu.com/s/1ggMazRl 密码: g3y3 ,在第9/31页开始讲。所以感谢安信可公司的奉献，让我们可以省去使用官方ubuntu镜像编译的开发方式！撒花ing… arduino IDE工具，这个也可以开发，不过我并不喜欢arduino所以我一眼都没看过23333。 附录 乐鑫公司官方文档资料、工具、demo下载地址:http://espressif.com/zh-hans/support/download/overview. 安信可公司官方的资料地址:http://wiki.ai-thinker.com/esp8266. 开发快公司提供免费的ESP8266模组的申请:http://bbs.kaifakuai.com/thread-981-1-1.html,注册之后就可以申请(我当时就是因为申请到了才开始玩ESP8266的，虽然很便宜但是抵不住他不要钱啊！！！).当然他们公司资料也很多的也很活跃，大家可以到处逛逛。开发快官方开发平台:http://developer.kaifakuai.com。QQ群:445880047。]]></content>
      <categories>
        <category>ESP8266</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ESP8266开发历程前言]]></title>
    <url>%2F2018%2F01%2F21%2FESP8266%E5%BC%80%E5%8F%91%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[意义：这算是第一个教程吧，ESP8266从大三到现在学了到现在，但是没有什么记录。回头又得拿着代码一点一点看，所以打算记录一下。同时也会兼顾一些解释和教程性质的东西，给能找到这的人看看吧，希望能给你一点帮助。 更新：更新的话，不定时。至于内容的顺序，就先按照一个hello world的实现来写，从引脚，IDE，下载工具，接线到写hello world，到下载查看。这些讲完的话打开你也就懂怎么做了。但是我不会写IO的使用因为我觉得他的定位作为wifi芯片比较好，就不要掺杂其他的的东西了(个人看法)。后面的软件层面的实现(主要是网络通信的应用)的话，也会写一部分。不过感觉网上其实挺多的教程(比较零散)，所以不排除会直接把比较好的搬运过来然后配合自己的理解说一下。]]></content>
      <categories>
        <category>ESP8266</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux系统目录讲解]]></title>
    <url>%2F2017%2F12%2F06%2Ffile%20system%2F</url>
    <content type="text"><![CDATA[/bin 目录 全称：Binary(Binaries) 作用：存放二进制可执行文件，例如命令行的cp命令。 备注：/bin下的命令是所有用户都可以执行的。/sbin(Spuer Binary)目录下的命令只有超级用户权限才能执行，比如分区操作。 /boot 目录 全称 ：Boot 作用 ：存放操作系统的引导启动需要的文件。一般100M左右(50~200)。 备注 ：里面存放的vmlinuz…文件就是操作系统的内核文件，他名字就是版本号。通过bash运行 uname -r可以看到系统的版本。grub引导同样在/boot下。 /dev 目录 全称 ：Device 作用 ：把计算机的硬件抽象为文件存储在/dev下面。诸如硬盘(hd×),处理器(cpu),网卡(net),usb等等。 /etc 目录 全称 ：Etcetera(其他)/Editable Text Configuration(可编辑配置文本) 作用 ：保存几乎所有的配置文件，系统的各个服务、组件、软件的配置文件存放地方，一般以.cnf或.conf结尾(configure)。 /home 目录 全称 ：Home 作用 ：存放除root用户之外所有用户的’家目录’的目录。 也就是每一个用户都会在/ｈome下有一个对应用户名的目录，用于存放该用户的私有数据。比如系统里有一个begild用户，那么/home下必有一个Beild文件夹。/home/begild下存放自己的桌面、文档等。 /lib 目录 全称 ：Library(Libraries) 作用 ：linux系统运行需要的共享库文件，相当于windows的.DLl文件(动态链接库)。一般以 .so (shared object)结尾。 备注：同样的还有/lib32、/lib64两个文件夹，作用和/lib相同，只是运用于32位还是64位。 /lost+found 目录 全称 ：lost+found 作用 ：用于存放系统发生错误的时候遗失的文件。 备注 ：只有root权限才能访问 /mnt 目录 全称 ：Mount(挂载) 作用 ：其他文件系统挂载的挂载点。使用mount命令挂载(手动挂载)。 备注 ：具备同样作用的还有/media目录，不过media目录一般用于实现自动挂载。 /opt 目录 全称 ：Optional application software packages(可选的应用程序) 作用 ：存放第三方、大型、版权保护的软件、游戏。 备注 ：安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。 /proc 目录 全称 ： 作用 ：存放进程信息，内核信息，内存使用等等快速变化的’文件’的目录。 备注 ：它本身不存在于实际的文件系统里。他是一种虚拟的文件系统。例如我们通过cat /proc/cpuinfo命令可以打开cpuinfo文件。里面完整的描述了cpu的信息。 /root 目录 全称 ：Root 作用 ：root用户的家目录，其他的用户家目录位于/home下。 /tmp 目录 全称 ：temp 作用 ：存放系统的临时文件,例如压缩文件预览.关机会自动清理,手动清理用tmpwatch命令. /usr 目录 全称 ：unix software resource 作用 ：软件安装的目录. /var 目录 全称 ：variable 作用 ：存放系统/软件运行过程中产生的缓存,登录日志等等文件.]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux目录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C函数指针]]></title>
    <url>%2F2017%2F10%2F28%2FC%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[当我们看到如下所示的代码怎么去理解它的意义呢。1(* ( void (*) () ) 0) () 解析这个函数需要下面几个知识 函数申明包含返回值，函数名，参数列表。 如返回值是’int’ 函数名为’fun’,参数列表为’void’。 1int fun(void); 函数指针和返回值为指针的函数 函数指针:函数指针pfun指向的是一个返回值为int类型，参数列表为空的函数。只要是符合这个’形状’的函数都可以吧地址赋给pfun。 1int (*pfun) (void); 返回值为指针的函数:返回值为int*类型的指针，参数列表为空的函数fun1。它表示fun1是一个确定的函数。不像pfun是可以指向任何符合模板的函数。 1int* fun1 (void); 所以在书写的时候必须注意是否需要加括号。 类型转化符。就像我们平时说的怎么把一个int强制转化为char呢，就是 12int a = 48;char b = (char) a; 我们怎么构建一个类型转化符呢，就是把目标类型用括号括起来，那么一个函数模板的类型转化符是怎么样的呢，就是把函数名去掉，然后用括号把他括起来。比如上面的函数指针pfun这个模板。我们只需要将pfun去掉，然后把剩下部分括起来。 1(int (*) (void) ) 这就是一个返回值为int参数列表为空的函数指针的强制类型转化符。 完成上述理解之后，我们着手理解一下1(* ( void (*) () ) 0) () 首先通过下面这个式子可以看出这是一个函数的调用，那么左括号里面的就是函名。1( funname ) () 也就是 1* (void (*) () ) 0 == funname 把0强制类型转化为void (*) () 型的函数指针。也就是指向函数地址为0的指针 1(void (*) () ) 0]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试编译器是否支持嵌套注释]]></title>
    <url>%2F2017%2F10%2F01%2F%E6%B5%8B%E8%AF%95%E7%BC%96%E8%AF%91%E5%99%A8%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%B5%8C%E5%A5%97%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"><![CDATA[问题：某些C编译器允许嵌套注释。请写一个测试程序，要求：无论是对允许嵌套注释的编译器，还是对不允许嵌套注释的编译器，该程序都能正常通过编译（无错误消息出现）， 但是这两种情况下程序执行的结果却不相同。 提示： 在用双引号括起的字符串中， 注释符 /* 属于字符串的一部分，而在注释中出现的双引号 “ “ 又属于注释的一部分。 出自——《C陷阱与缺陷》练习1-1 嵌套注释：顾名思义就是注释里嵌套着注释。比如1/*"/*"*/"*/ 对于这段代码，不同的编译器识别的结果不同： 我们如何通过代码的输出判定编译器是否支持嵌套注释呢，重点就是让同一段代码，支持嵌套注释的编译器和不支持嵌套注释的编译器注释掉不同的地方。根据题目的提示字符串中的 /* 是属于字符串的一部分，比如 “/*aa*/“ 这里面的注释标号编译器是不会理会的，而 /*“aa*“/ 这里面的 “aa” 是不会识别为字符串的。还有一点无论是 “ “ 还是 /**/都是就近匹配的。 我们首先构建一个嵌套的注释，这个注释在支持嵌套注释的编译器里能编译通过，而在不支持的编译器里编译失败：1/*"/*"*/"*/ 不支持的系统中出现了”*/“导致编译失败 我们通过添加一个 “ 使得不支持的系统编译成功1/*"/*"*/"*/" 可以看出这样添加之后不支持的编译器已经能编译成功并且有输出一字符串，支持的系统由于多了一个 “ 导致编译失败，根据题目提示我们构建一个字符串” “并且”/*,*/“ 两两配对，所以我们添加一个 /*形成”/*“ 1/*"/*"*/"*/"/*" 这样操作之后支持/不支持的编译器输出不同的字符串(蓝色部分),但是不支持的编译器多了 /* “编译失败，而它刚好又是多行注释的头,所以我们得加一个尾 */ 使得他们配对。1/*"/*"*/"*/"/*"*/ 我们从上图可以看出不支持嵌套注释的编译器已经能通过编译并且有区别去支持嵌套注释的编译器的输出。但是支持嵌套注释的编译器由于多了*/导致编译失败，因为不支持嵌套注释的编译器的注释之间无论是什么都可以忽略，所以我们在最后的 */ 之前加一个 /* 让支持嵌套注释的编译器能找到配对的注释对。1/*"/*"*/"*/"/*"/**/ 通过上述步骤我们找到了一个合适的语句使得在两种编译器中编译成功并且有不同的输出。 通过一段简单的代码我们可以看下效果 1234567891011121314151617#include &lt;stdio.h&gt;int ISSupNestComment(void);int main()&#123; printf("This compiler %s support nested comment \r\n", ISSupNestComment()? "": "does not"); return 0;&#125;int ISSupNestComment()&#123; char *Str=/*"/*"*/"*/"/*"/**/; if(Str[0]=='*')//"*/"不支持嵌套注释 return 0; else //"/*"支持嵌套注释 return 1;&#125; 自己做完这个感觉还是有点意思的，上网搜了一波，发现别人想的更是精妙。不禁发出一套赞赏三连，卧槽牛逼666。下面我们看下一大佬们是怎么做的。 1.Doug McIlroy1/*/*/0*/**/1 这个解法主要利用了编译器作词法分析时的“大嘴法”规则。编译器支持嵌套注释，则上式将被解释为1.编译器不支持嵌套注释，则上式将被解释为 0*1. 2.TimWu1234567891011#define A /* aaa /* a*/ a#define B */bool CanNesting()&#123;#ifdef B return false;#else return true;#endif&#125; 他利用的多行注释和宏定义的特性，编译器支持嵌套注释宏定义B则会被注释掉导致没有宏定义B。编译器不支持嵌套注释，宏定义B则会定义为 */。通过预编译判断就可以输出结果。]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>嵌套注释</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理器大小端存储模式]]></title>
    <url>%2F2017%2F09%2F13%2F%E5%A4%A7%E5%B0%8F%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[大端模式：是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。 小端模式：是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。 例如：一个数据无符号32位整数0x12345678,其中0x12属于高字节(权值大)而0x78属于低字节(权值小),在不同的模式下存储的方式如下表： 内存地址 0x1000 0x1001 0x1002 0x1003 大端模式 0x12 0x34 0x56 0x78 小端模式 0x78 0x56 0x34 0x12 我们可以看得出来大端模式和我们的阅读习惯相同，权值从左往右是高位-&gt;低位而地址则是低位-&gt;高位。小端模式则是随着地址从左往右增大权值增大。地址就代表了权值的大小。 利用下面c代码可以看到运行环境是如何存储一个uint数据的。 12345678910111213#include &lt;stdio.h&gt;int endian(void);int main(int argc,char arg[])&#123; unsigned int a=0x12345678; char *ap=&amp;a; int i=0; printf("0x%x storage in system is:\r\n",a); for(i=0;i&lt;4;i++) printf("addr:0x%x,value:0x%x\r\n",ap+i,ap[i]); printf("system storage by %s_endian",endian()? "Big":"Little"); return 0;&#125; 运行的结果如下，可以看出该系统是小端系统。 我们如何简单的判断一个系统的大小端呢。我们知道共用体(联合体)存储在内存里是共用一块地址的，其占用空间决定于最大成员所需的空间,他们的起始地址相同。所以我们可以利用一个共用体,成员分别是一个int和一个char。通过给int赋值1，然后检测char对应的值是多少，如果是1代表系统将数据1放到了int的起始地址(因为char是一个字节必然在起始地址)。而起始地址是低地址，低地址存放的1(权值小)推出该系统是小端系统。否则该系统是大端系统。 C代码如下1234567891011int endian()&#123; union&#123; int a; char b; &#125;endunion; endunion.a=1; if(endunion.b==1)//如果成员b是1则证明随地址顺序和数字权值顺序相同是小端模式 return 0;//小端 return 1;//大端&#125; 还可以用一个更加简洁的办法(原理都是检测int的起始地址存放的是什么值)，代码如下12345int endian()&#123; int a=1; return !(*((char *)&amp;a));//取a的地址，将其强制转化为char指针，然后取出该地址存放的值并取反;&#125;]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>大小端存储</tag>
      </tags>
  </entry>
</search>
